var mt=Object.defineProperty;var qe=Object.getOwnPropertySymbols;var ht=Object.prototype.hasOwnProperty,pt=Object.prototype.propertyIsEnumerable;var ze=(w,S,j)=>S in w?mt(w,S,{enumerable:!0,configurable:!0,writable:!0,value:j}):w[S]=j,Ue=(w,S)=>{for(var j in S||(S={}))ht.call(S,j)&&ze(w,j,S[j]);if(qe)for(var j of qe(S))pt.call(S,j)&&ze(w,j,S[j]);return w};import{r as ae,C as gt,s as re}from"./vendor.65bf52f0.js";import{j as ee,F as yt,a as Oe,C as bt,b as vt}from"./index.4795f95b.js";var be=w=>w.type==="checkbox",fe=w=>w instanceof Date,Z=w=>w==null;const Be=w=>typeof w=="object";var Y=w=>!Z(w)&&!Array.isArray(w)&&Be(w)&&!fe(w),_t=w=>w.substring(0,w.search(/.\d/))||w,wt=(w,S)=>[...w].some(j=>_t(S)===j),ge=w=>w.filter(Boolean),H=w=>w===void 0,T=(w,S,j)=>{if(Y(w)&&S){const D=ge(S.split(/[,[\].]+?/)).reduce((O,x)=>Z(O)?O:O[x],w);return H(D)||D===w?H(w[S])?j:w[S]:D}};const xt={BLUR:"blur",CHANGE:"change"},X={onBlur:"onBlur",onChange:"onChange",onSubmit:"onSubmit",onTouched:"onTouched",all:"all"},se={max:"max",min:"min",maxLength:"maxLength",minLength:"minLength",pattern:"pattern",required:"required",validate:"validate"};var ke=(w,S)=>{const j=Object.assign({},w);return delete j[S],j};ae.exports.createContext(null);var $t=(w,S,j,D=!0)=>{function O(g){return()=>{if(g in w)return S[g]!==X.all&&(S[g]=!D||X.all),j&&(j[g]=!0),w[g]}}const x={};for(const g in w)Object.defineProperty(x,g,{get:O(g)});return x},J=w=>Y(w)&&!Object.keys(w).length,jt=(w,S,j)=>{const D=ke(w,"name");return J(D)||Object.keys(D).length>=Object.keys(S).length||Object.keys(D).find(O=>S[O]===(!j||X.all))},Se=w=>Array.isArray(w)?w:[w];const We=w=>{w.current&&(w.current.unsubscribe(),w.current=void 0)},Ot=({_subscription:w,props:S})=>{S.disabled?We(w):w.current||(w.current=S.subject.subscribe({next:S.callback}))};function kt(w){const S=ae.exports.useRef();Ot({_subscription:S,props:w}),ae.exports.useEffect(()=>()=>We(S),[])}var te=w=>typeof w=="string";function St(w,S,j,D){const O=Array.isArray(w);return te(w)?(D&&S.watch.add(w),T(j,w)):O?w.map(x=>(D&&S.watch.add(x),T(j,x))):(D&&(S.watchAll=!0),j)}var Ae=w=>/^\w*$/.test(w),He=w=>ge(w.replace(/["|']|\]/g,"").split(/\.|\[/));function U(w,S,j){let D=-1;const O=Ae(S)?[S]:He(S),x=O.length,g=x-1;for(;++D<x;){const l=O[D];let _=j;if(D!==g){const y=w[l];_=Y(y)||Array.isArray(y)?y:isNaN(+O[D+1])?{}:[]}w[l]=_,w=w[l]}return w}var Ge=(w,S,j,D,O)=>S?Object.assign(Object.assign({},j[w]),{types:Object.assign(Object.assign({},j[w]&&j[w].types?j[w].types:{}),{[D]:O||!0})}):{};const Re=(w,S,j)=>{for(const D of j||Object.keys(w)){const O=T(w,D);if(O){const x=O._f,g=ke(O,"_f");if(x&&S(x.name)){if(x.ref.focus&&H(x.ref.focus()))break;if(x.refs){x.refs[0].focus();break}}else Y(g)&&Re(g,S)}}};var Ee=w=>typeof w=="function";function ve(w){let S;const j=Array.isArray(w);if(w instanceof Date)S=new Date(w);else if(w instanceof Set)S=new Set(w);else if(j||Y(w)){S=j?[]:{};for(const D in w){if(Ee(w[D])){S=w;break}S[D]=ve(w[D])}}else return w;return S}function De(){let w=[];return{get observers(){return w},next:O=>{for(const x of w)x.next(O)},subscribe:O=>(w.push(O),{unsubscribe:()=>{w=w.filter(x=>x!==O)}}),unsubscribe:()=>{w=[]}}}var ye=w=>Z(w)||!Be(w);function de(w,S){if(ye(w)||ye(S))return w===S;if(fe(w)&&fe(S))return w.getTime()===S.getTime();const j=Object.keys(w),D=Object.keys(S);if(j.length!==D.length)return!1;for(const O of j){const x=w[O];if(!D.includes(O))return!1;if(O!=="ref"){const g=S[O];if(fe(x)&&fe(g)||Y(x)&&Y(g)||Array.isArray(x)&&Array.isArray(g)?!de(x,g):x!==g)return!1}}return!0}var Ke=w=>({isOnSubmit:!w||w===X.onSubmit,isOnBlur:w===X.onBlur,isOnChange:w===X.onChange,isOnAll:w===X.all,isOnTouch:w===X.onTouched}),me=w=>typeof w=="boolean",Ce=w=>w.type==="file",Fe=w=>w instanceof HTMLElement,Ze=w=>w.type==="select-multiple",Ie=w=>w.type==="radio",At=w=>Ie(w)||be(w),Ye=typeof window!="undefined"&&typeof window.HTMLElement!="undefined"&&typeof document!="undefined",Me=w=>Fe(w)&&document.contains(w);function Rt(w,S){const j=S.slice(0,-1).length;let D=0;for(;D<j;)w=H(w)?D++:w[S[D++]];return w}function G(w,S){const j=Ae(S)?[S]:He(S),D=j.length==1?w:Rt(w,j),O=j[j.length-1];let x;D&&delete D[O];for(let g=0;g<j.slice(0,-1).length;g++){let l=-1,_;const y=j.slice(0,-(g+1)),d=y.length-1;for(g>0&&(x=w);++l<y.length;){const e=y[l];_=_?_[e]:w[e],d===l&&(Y(_)&&J(_)||Array.isArray(_)&&!_.filter(n=>Y(n)&&!J(n)||me(n)).length)&&(x?delete x[e]:delete w[e]),x=_}}return w}const Je={value:!1,isValid:!1},Qe={value:!0,isValid:!0};var Xe=w=>{if(Array.isArray(w)){if(w.length>1){const S=w.filter(j=>j&&j.checked&&!j.disabled).map(j=>j.value);return{value:S,isValid:!!S.length}}return w[0].checked&&!w[0].disabled?w[0].attributes&&!H(w[0].attributes.value)?H(w[0].value)||w[0].value===""?Qe:{value:w[0].value,isValid:!0}:Qe:Je}return Je},et=(w,{valueAsNumber:S,valueAsDate:j,setValueAs:D})=>H(w)?w:S?w===""?NaN:+w:j?new Date(w):D?D(w):w;const tt={isValid:!1,value:null};var rt=w=>Array.isArray(w)?w.reduce((S,j)=>j&&j.checked&&!j.disabled?{isValid:!0,value:j.value}:S,tt):tt;function Pe(w){const S=w.ref;if(!(w.refs?w.refs.every(j=>j.disabled):S.disabled))return Ce(S)?S.files:Ie(S)?rt(w.refs).value:Ze(S)?[...S.selectedOptions].map(({value:j})=>j):be(S)?Xe(w.refs).value:et(H(S.value)?w.ref.value:S.value,w)}var Et=(w,S,j,D)=>{const O={};for(const x of w){const g=T(S,x);g&&U(O,x,g._f)}return{criteriaMode:j,names:[...w],fields:O,shouldUseNativeValidation:D}},Dt=w=>w.mount&&(w.required||w.min||w.max||w.maxLength||w.minLength||w.pattern||w.validate);function st(w,S,j){const D=T(w,j);if(D||Ae(j))return{error:D,name:j};const O=j.split(".");for(;O.length;){const x=O.join("."),g=T(S,x),l=T(w,x);if(g&&!Array.isArray(g)&&j!==x)return{name:j};if(l&&l.type)return{name:x,error:l};O.pop()}return{name:j}}function nt(w,S){if(ye(w)||ye(S))return S;for(const j in S){const D=w[j],O=S[j];try{w[j]=Y(D)&&Y(O)||Array.isArray(D)&&Array.isArray(O)?nt(D,O):O}catch{}}return w}function Le(w,S,j,D,O){let x=-1;for(;++x<w.length;){for(const g in w[x])Array.isArray(w[x][g])?(!j[x]&&(j[x]={}),j[x][g]=[],Le(w[x][g],T(S[x]||{},g,[]),j[x][g],j[x],g)):!Z(S)&&de(T(S[x]||{},g),w[x][g])?U(j[x]||{},g):j[x]=Object.assign(Object.assign({},j[x]),{[g]:!0});D&&!j.length&&delete D[O]}return j}var Ct=(w,S,j)=>nt(Le(w,S,j.slice(0,w.length)),Le(S,w,j.slice(0,w.length))),Ft=(w,S,j,D,O)=>O.isOnAll?!1:!j&&O.isOnTouch?!(S||w):(j?D.isOnBlur:O.isOnBlur)?!w:(j?D.isOnChange:O.isOnChange)?w:!0,Te=(w,S)=>!ge(T(w,S,[])).length&&G(w,S),_e=w=>te(w)||ae.exports.isValidElement(w),at=w=>w instanceof RegExp;function it(w,S,j="validate"){if(_e(w)||Array.isArray(w)&&w.every(_e)||me(w)&&!w)return{type:j,message:_e(w)?w:"",ref:S}}var he=w=>Y(w)&&!at(w)?w:{value:w,message:""},ot=async(w,S,j,D)=>{const{ref:O,refs:x,required:g,maxLength:l,minLength:_,min:y,max:d,pattern:e,validate:n,name:c,valueAsNumber:r,mount:t,disabled:s}=w._f;if(!t||s)return{};const i=x?x[0]:O,o=h=>{D&&i.reportValidity&&(i.setCustomValidity(me(h)?"":h||" "),i.reportValidity())},f={},a=Ie(O),m=be(O),v=a||m,b=(r||Ce(O))&&!O.value||S===""||Array.isArray(S)&&!S.length,u=Ge.bind(null,c,j,f),p=(h,$,A,R=se.maxLength,F=se.minLength)=>{const L=h?$:A;f[c]=Object.assign({type:h?R:F,message:L,ref:O},u(h?R:F,L))};if(g&&(!v&&(b||Z(S))||me(S)&&!S||m&&!Xe(x).isValid||a&&!rt(x).isValid)){const{value:h,message:$}=_e(g)?{value:!!g,message:g}:he(g);if(h&&(f[c]=Object.assign({type:se.required,message:$,ref:i},u(se.required,$)),!j))return o($),f}if(!b&&(!Z(y)||!Z(d))){let h,$;const A=he(d),R=he(y);if(isNaN(S)){const F=O.valueAsDate||new Date(S);te(A.value)&&(h=F>new Date(A.value)),te(R.value)&&($=F<new Date(R.value))}else{const F=O.valueAsNumber||parseFloat(S);Z(A.value)||(h=F>A.value),Z(R.value)||($=F<R.value)}if((h||$)&&(p(!!h,A.message,R.message,se.max,se.min),!j))return o(f[c].message),f}if((l||_)&&!b&&te(S)){const h=he(l),$=he(_),A=!Z(h.value)&&S.length>h.value,R=!Z($.value)&&S.length<$.value;if((A||R)&&(p(A,h.message,$.message),!j))return o(f[c].message),f}if(e&&!b&&te(S)){const{value:h,message:$}=he(e);if(at(h)&&!S.match(h)&&(f[c]=Object.assign({type:se.pattern,message:$,ref:O},u(se.pattern,$)),!j))return o($),f}if(n){if(Ee(n)){const h=await n(S),$=it(h,i);if($&&(f[c]=Object.assign(Object.assign({},$),u(se.validate,$.message)),!j))return o($.message),f}else if(Y(n)){let h={};for(const $ in n){if(!J(h)&&!j)break;const A=it(await n[$](S),i,$);A&&(h=Object.assign(Object.assign({},A),u($,A.message)),o(A.message),j&&(f[c]=h))}if(!J(h)&&(f[c]=Object.assign({ref:i},h),!j))return f}}return o(!0),f};const It={mode:X.onSubmit,reValidateMode:X.onChange,shouldFocusError:!0},Mt=typeof window=="undefined";function Pt(w={}){let S=Object.assign(Object.assign({},It),w),j={isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,errors:{}},D={},O=S.defaultValues||{},x=S.shouldUnregister?{}:ve(O),g={action:!1,mount:!1,watch:!1},l={mount:new Set,unMount:new Set,array:new Set,watch:new Set},_,y=0,d={};const e={isDirty:!1,dirtyFields:!1,touchedFields:!1,isValidating:!1,isValid:!1,errors:!1},n={watch:De(),array:De(),state:De()},c=Ke(S.mode),r=Ke(S.reValidateMode),t=S.criteriaMode===X.all,s=(k,E)=>(...C)=>{clearTimeout(y),y=window.setTimeout(()=>k(...C),E)},i=(k,E)=>!E&&(l.watchAll||l.watch.has(k)||l.watch.has((k.match(/\w+/)||[])[0])),o=async k=>{let E=!1;return e.isValid&&(E=S.resolver?J((await p()).errors):await $(D,!0),!k&&E!==j.isValid&&(j.isValid=E,n.state.next({isValid:E}))),E},f=(k,E,C,P=[],M=!0,I=!0)=>{if(g.action=!0,I&&T(D,k)){const N=E(T(D,k),C.argA,C.argB);M&&U(D,k,N)}if(Array.isArray(T(j.errors,k))){const N=E(T(j.errors,k),C.argA,C.argB);M&&U(j.errors,k,N),Te(j.errors,k)}if(e.touchedFields&&T(j.touchedFields,k)){const N=E(T(j.touchedFields,k),C.argA,C.argB);M&&U(j.touchedFields,k,N),Te(j.touchedFields,k)}(e.dirtyFields||e.isDirty)&&b(k,P),n.state.next({isDirty:R(k,P),dirtyFields:j.dirtyFields,errors:j.errors,isValid:j.isValid})},a=(k,E)=>(U(j.errors,k,E),n.state.next({errors:j.errors})),m=(k,E,C)=>{const P=T(D,k);if(P){const M=T(x,k,T(O,k));H(M)||C&&C.defaultChecked||E?U(x,k,E?M:Pe(P._f)):V(k,M)}g.mount&&o()},v=(k,E,C,P=!0)=>{let M=!1;const I={name:k},N=T(j.touchedFields,k);if(e.isDirty){const z=j.isDirty;j.isDirty=I.isDirty=R(),M=z!==I.isDirty}if(e.dirtyFields&&!C){const z=T(j.dirtyFields,k);de(T(O,k),E)?G(j.dirtyFields,k):U(j.dirtyFields,k,!0),I.dirtyFields=j.dirtyFields,M=M||z!==T(j.dirtyFields,k)}return C&&!N&&(U(j.touchedFields,k,C),I.touchedFields=j.touchedFields,M=M||e.touchedFields&&N!==C),M&&P&&n.state.next(I),M?I:{}},b=(k,E)=>(U(j.dirtyFields,k,Ct(E,T(O,k,[]),T(j.dirtyFields,k,[]))),Te(j.dirtyFields,k)),u=async(k,E,C,P,M)=>{const I=T(j.errors,E),N=e.isValid&&j.isValid!==C;if(w.delayError&&P?(_=_||s(a,w.delayError),_(E,P)):(clearTimeout(y),P?U(j.errors,E,P):G(j.errors,E)),((P?!de(I,P):I)||!J(M)||N)&&!k){const z=Object.assign(Object.assign(Object.assign({},M),N?{isValid:C}:{}),{errors:j.errors,name:E});j=Object.assign(Object.assign({},j),z),n.state.next(z)}d[E]--,e.isValidating&&!d[E]&&(n.state.next({isValidating:!1}),d={})},p=async k=>S.resolver?await S.resolver(Object.assign({},x),S.context,Et(k||l.mount,D,S.criteriaMode,S.shouldUseNativeValidation)):{},h=async k=>{const{errors:E}=await p();if(k)for(const C of k){const P=T(E,C);P?U(j.errors,C,P):G(j.errors,C)}else j.errors=E;return E},$=async(k,E,C={valid:!0})=>{for(const P in k){const M=k[P];if(M){const I=M._f,N=ke(M,"_f");if(I){const z=await ot(M,T(x,I.name),t,S.shouldUseNativeValidation);if(z[I.name]&&(C.valid=!1,E))break;E||(z[I.name]?U(j.errors,I.name,z[I.name]):G(j.errors,I.name))}N&&await $(N,E,C)}}return C.valid},A=()=>{for(const k of l.unMount){const E=T(D,k);E&&(E._f.refs?E._f.refs.every(C=>!Me(C)):!Me(E._f.ref))&&le(k)}l.unMount=new Set},R=(k,E)=>(k&&E&&U(x,k,E),!de(B(),O)),F=(k,E,C)=>{const P=Object.assign({},g.mount?x:H(E)?O:te(k)?{[k]:E}:E);return St(k,l,P,C)},L=k=>T(g.mount?x:O,k,w.shouldUnregister?T(O,k,[]):[]),V=(k,E,C={})=>{const P=T(D,k);let M=E;if(P){const I=P._f;I&&(U(x,k,et(E,I)),M=Ye&&Fe(I.ref)&&Z(E)?"":E,Ce(I.ref)&&!te(M)?I.ref.files=M:Ze(I.ref)?[...I.ref.options].forEach(N=>N.selected=M.includes(N.value)):I.refs?be(I.ref)?I.refs.length>1?I.refs.forEach(N=>N.checked=Array.isArray(M)?!!M.find(z=>z===N.value):M===N.value):I.refs[0].checked=!!M:I.refs.forEach(N=>N.checked=N.value===M):I.ref.value=M)}(C.shouldDirty||C.shouldTouch)&&v(k,M,C.shouldTouch),C.shouldValidate&&q(k)},W=(k,E,C)=>{for(const P in E){const M=E[P],I=`${k}.${P}`,N=T(D,I);(l.array.has(k)||!ye(M)||N&&!N._f)&&!fe(M)?W(I,M,C):V(I,M,C)}},K=(k,E,C={})=>{const P=T(D,k),M=l.array.has(k);U(x,k,E),M?(n.array.next({name:k,values:x}),(e.isDirty||e.dirtyFields)&&C.shouldDirty&&(b(k,E),n.state.next({name:k,dirtyFields:j.dirtyFields,isDirty:R(k,E)}))):P&&!P._f&&!Z(E)?W(k,E,C):V(k,E,C),i(k)&&n.state.next({}),n.watch.next({name:k})},ie=async k=>{const E=k.target;let C=E.name;const P=T(D,C);if(P){let M,I;const N=E.type?Pe(P._f):E.value,z=k.type===xt.BLUR,xe=!Dt(P._f)&&!S.resolver&&!T(j.errors,C)&&!P._f.deps||Ft(z,T(j.touchedFields,C),j.isSubmitted,r,c),$e=i(C,z);z?P._f.onBlur&&P._f.onBlur(k):P._f.onChange&&P._f.onChange(k),U(x,C,N);const je=v(C,N,z,!1),ft=!J(je)||$e;if(!z&&n.watch.next({name:C,type:k.type}),xe)return ft&&n.state.next(Object.assign({name:C},$e?{}:je));if(!z&&$e&&n.state.next({}),d[C]=(d[C],1),e.isValidating&&n.state.next({isValidating:!0}),S.resolver){const{errors:Ne}=await p([C]),dt=st(j.errors,D,C),Ve=st(Ne,D,dt.name||C);M=Ve.error,C=Ve.name,I=J(Ne)}else M=(await ot(P,T(x,C),t,S.shouldUseNativeValidation))[C],I=await o(!0);P._f.deps&&q(P._f.deps),u(!1,C,I,M,je)}},q=async(k,E={})=>{let C,P;const M=Se(k);if(n.state.next({isValidating:!0}),S.resolver){const I=await h(H(k)?k:M);C=J(I),P=k?!M.some(N=>T(I,N)):C}else k?(P=(await Promise.all(M.map(async I=>{const N=T(D,I);return await $(N&&N._f?{[I]:N}:N)}))).every(Boolean),!(!P&&!j.isValid)&&o()):P=C=await $(D);return n.state.next(Object.assign(Object.assign(Object.assign({},!te(k)||e.isValid&&C!==j.isValid?{}:{name:k}),S.resolver?{isValid:C}:{}),{errors:j.errors,isValidating:!1})),E.shouldFocus&&!P&&Re(D,I=>T(j.errors,I),k?M:l.mount),P},B=k=>{const E=Object.assign(Object.assign({},O),g.mount?x:{});return H(k)?E:te(k)?T(E,k):k.map(C=>T(E,C))},Q=k=>{k?Se(k).forEach(E=>G(j.errors,E)):j.errors={},n.state.next({errors:j.errors,isValid:!0})},ne=(k,E,C)=>{const P=(T(D,k,{_f:{}})._f||{}).ref;U(j.errors,k,Object.assign(Object.assign({},E),{ref:P})),n.state.next({name:k,errors:j.errors,isValid:!1}),C&&C.shouldFocus&&P&&P.focus&&P.focus()},oe=(k,E)=>Ee(k)?n.watch.subscribe({next:C=>k(F(void 0,E),C)}):F(k,E,!0),le=(k,E={})=>{for(const C of k?Se(k):l.mount)l.mount.delete(C),l.array.delete(C),T(D,C)&&(E.keepValue||(G(D,C),G(x,C)),!E.keepError&&G(j.errors,C),!E.keepDirty&&G(j.dirtyFields,C),!E.keepTouched&&G(j.touchedFields,C),!S.shouldUnregister&&!E.keepDefaultValue&&G(O,C));n.watch.next({}),n.state.next(Object.assign(Object.assign({},j),E.keepDirty?{isDirty:R()}:{})),!E.keepIsValid&&o()},ce=(k,E={})=>{const C=T(D,k);return U(D,k,{_f:Object.assign(Object.assign(Object.assign({},C&&C._f?C._f:{ref:{name:k}}),{name:k,mount:!0}),E)}),l.mount.add(k),!H(E.value)&&!E.disabled&&U(x,k,T(x,k,E.value)),C?me(E.disabled)&&U(x,k,E.disabled?void 0:T(x,k,Pe(C._f))):m(k,!0),Mt?{name:k}:Object.assign(Object.assign({name:k},me(E.disabled)?{disabled:E.disabled}:{}),{onChange:ie,onBlur:ie,ref:P=>{if(P){ce(k,E);let M=T(D,k);const I=H(P.value)&&P.querySelectorAll&&P.querySelectorAll("input,select,textarea")[0]||P,N=At(I);if(I===M._f.ref||N&&ge(M._f.refs||[]).find(z=>z===I))return;M={_f:N?Object.assign(Object.assign({},M._f),{refs:[...ge(M._f.refs||[]).filter(Me),I],ref:{type:I.type,name:k}}):Object.assign(Object.assign({},M._f),{ref:I})},U(D,k,M),(!E||!E.disabled)&&m(k,!1,I)}else{const M=T(D,k,{}),I=S.shouldUnregister||E.shouldUnregister;M._f&&(M._f.mount=!1),I&&!(wt(l.array,k)&&g.action)&&l.unMount.add(k)}}})};return{control:{register:ce,unregister:le,_executeSchema:p,_getWatch:F,_getDirty:R,_updateValid:o,_removeUnmounted:A,_updateFieldArray:f,_getFieldArray:L,_subjects:n,_proxyFormState:e,get _fields(){return D},set _fields(k){D=k},get _formValues(){return x},set _formValues(k){x=k},get _stateFlags(){return g},set _stateFlags(k){g=k},get _defaultValues(){return O},set _defaultValues(k){O=k},get _names(){return l},set _names(k){l=k},get _formState(){return j},set _formState(k){j=k},get _options(){return S},set _options(k){S=Object.assign(Object.assign({},S),k)}},trigger:q,register:ce,handleSubmit:(k,E)=>async C=>{C&&(C.preventDefault&&C.preventDefault(),C.persist&&C.persist());let P=!0,M=Object.assign({},x);n.state.next({isSubmitting:!0});try{if(S.resolver){const{errors:I,values:N}=await p();j.errors=I,M=N}else await $(D);J(j.errors)&&Object.keys(j.errors).every(I=>T(M,I))?(n.state.next({errors:{},isSubmitting:!0}),await k(M,C)):(E&&await E(j.errors,C),S.shouldFocusError&&Re(D,I=>T(j.errors,I),l.mount))}catch(I){throw P=!1,I}finally{j.isSubmitted=!0,n.state.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:J(j.errors)&&P,submitCount:j.submitCount+1,errors:j.errors})}},watch:oe,setValue:K,getValues:B,reset:(k,E={})=>{const C=k||O,P=ve(C),M=J(k)?O:P;if(E.keepDefaultValues||(O=C),!E.keepValues){if(Ye)for(const I of l.mount){const N=T(D,I);if(N&&N._f){const z=Array.isArray(N._f.refs)?N._f.refs[0]:N._f.ref;try{Fe(z)&&z.closest("form").reset();break}catch{}}}x=w.shouldUnregister?E.keepDefaultValues?ve(O):{}:P,D={},n.watch.next({values:M}),n.array.next({values:M})}l={mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1,focus:""},n.state.next({submitCount:E.keepSubmitCount?j.submitCount:0,isDirty:E.keepDirty?j.isDirty:E.keepDefaultValues?!de(k,O):!1,isSubmitted:E.keepIsSubmitted?j.isSubmitted:!1,dirtyFields:E.keepDirty?j.dirtyFields:E.keepDefaultValues&&k?Object.entries(k).reduce((I,[N,z])=>Object.assign(Object.assign({},I),{[N]:z!==T(O,N)}),{}):{},touchedFields:E.keepTouched?j.touchedFields:{},errors:E.keepErrors?j.errors:{},isSubmitting:!1,isSubmitSuccessful:!1}),g.mount=!e.isValid||!!E.keepIsValid,g.watch=!!w.shouldUnregister},resetField:(k,E={})=>{H(E.defaultValue)?K(k,T(O,k)):(K(k,E.defaultValue),U(O,k,E.defaultValue)),E.keepTouched||G(j.touchedFields,k),E.keepDirty||(G(j.dirtyFields,k),j.isDirty=E.defaultValue?R(k,T(O,k)):R()),E.keepError||(G(j.errors,k),e.isValid&&o()),n.state.next(Object.assign({},j))},clearErrors:Q,unregister:le,setError:ne,setFocus:k=>{const E=T(D,k)._f;(E.ref.focus?E.ref:E.refs[0]).focus()}}}function Lt(w={}){const S=ae.exports.useRef(),[j,D]=ae.exports.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,errors:{}});S.current?S.current.control._options=w:S.current=Object.assign(Object.assign({},Pt(w)),{formState:j});const O=S.current.control;return kt({subject:O._subjects.state,callback:x=>{jt(x,O._proxyFormState,!0)&&(O._formState=Object.assign(Object.assign({},O._formState),x),D(Object.assign({},O._formState)))}}),ae.exports.useEffect(()=>{O._stateFlags.mount||(O._proxyFormState.isValid&&O._updateValid(),O._stateFlags.mount=!0),O._stateFlags.watch&&(O._stateFlags.watch=!1,O._subjects.state.next({})),O._removeUnmounted()}),ae.exports.useEffect(()=>()=>Object.values(O._subjects).forEach(x=>x.unsubscribe()),[O]),S.current.formState=$t(j,O._proxyFormState),S.current}const Tt=[{name:"name",type:"text",placeholder:"Name"},{name:"email",type:"text",placeholder:"Email"},{name:"password",type:"password",placeholder:"Password"},{name:"confirmPassword",type:"password",placeholder:"Confirm Password"}],Nt=gt`
  min-height: 100vh;
  color: #fff;
  background-color: #101522;
  margin: 0;
  padding: 10rem 2rem;
`,Vt=re.h1`
  font-size: 4rem;
  margin: 0;
  padding-bottom: 1rem;
  color: #fff;
  text-align: center;
`,qt=re.p`
  font-size: 1.2rem;
  color: #fffa;
  margin-bottom: 3rem;
  text-align: center;
`,lt=re.p`
  font-size: 1rem;
  color: #f00a;
  margin: 0;
  padding: 0;
  padding-bottom: 1rem;
`,zt=re(lt)`
  color: rebeccapurple;
  font-weight: 600;
  text-align: center;
`;re.div`
  background-color: #fff;
  padding: 1rem 2rem 0;
`;const Ut=re.form`
  background-color: #fff;
  border-radius: 1rem;
  /* box-shadow: 0 0 20px 0 rebeccapurple; */
  padding: 3rem 2rem;
  width: 90vw;
  ${w=>w.theme.media.md} {
    width: 40vw;
    /* padding: 5rem; */
  }
  ${w=>w.theme.media.lg} {
    width: 30vw;
    /* padding: 5rem 15rem; */
  }
`,Bt=re.input`
  background-color: #fff;
  padding: 1rem;
  width: 100%;
  border: 1px solid #0008;
  border-radius: 0.3rem;
  outline: none;
  margin: 0;
  margin-bottom: 1rem;
  :focus-visible {
    border: 1px solid #f00a;
    border: 1px solid rebeccapurple;
  }
`,Wt=re.input.attrs(w=>({type:"submit"}))`
  margin-top: 2rem;
  padding: 1rem;
  width: 100%;
  color: #fff;
  text-transform: uppercase;
  border: none;
  background-color: rebeccapurple;
  :hover {
    opacity: 0.9;
  }
  :active {
    opacity: 1;
  }
  :disabled {
    opacity: 0.5;
  }
`;var ct=function(w,S){for(var j in S.fields){var D=S.fields[j];if(D&&D.ref&&"reportValidity"in D.ref){var O=T(w,j);D.ref.setCustomValidity(O&&O.message||""),D.ref.reportValidity()}}},Ht=function(w,S){S.shouldUseNativeValidation&&ct(w,S);var j={};for(var D in w){var O=T(S.fields,D);U(j,D,Object.assign(w[D],{ref:O&&O.ref}))}return j},Gt=function(w,S,j){return S===void 0&&(S={abortEarly:!1}),j===void 0&&(j={}),function(D,O,x){try{var g=function(){return _.error?{values:{},errors:Ht((d=_.error,e=!x.shouldUseNativeValidation&&x.criteriaMode==="all",d.details.length?d.details.reduce(function(n,c){var r=c.path.join(".");if(n[r]||(n[r]={message:c.message,type:c.type}),e){var t=n[r].types,s=t&&t[c.type];n[r]=Ge(r,e,n,c.type,s?[].concat(s,c.message):c.message)}return n},{}):{}),x)}:(x.shouldUseNativeValidation&&ct({},x),{errors:{},values:_.value});var d,e},l=Object.assign({},S,{context:O}),_={},y=function(){if(j.mode==="sync")_=w.validate(D,l);else{var d=function(e,n){try{var c=e()}catch(r){return n(r)}return c&&c.then?c.then(void 0,n):c}(function(){return Promise.resolve(w.validateAsync(D,l)).then(function(e){_.value=e})},function(e){_.error=e});if(d&&d.then)return d.then(function(){})}}();return Promise.resolve(y&&y.then?y.then(g):g())}catch(d){return Promise.reject(d)}}},ut={exports:{}};(function(w,S){(function(j,D){w.exports=D()})(self,function(){return j={1238:O=>{O.exports={version:"17.4.2"}},7629:(O,x,g)=>{const l=g(375),_=g(8571),y=g(9474),d=g(1687),e=g(8652),n=g(8160),c=g(3292),r=g(6354),t=g(8901),s=g(9708),i=g(6914),o=g(2294),f=g(6133),a=g(1152),m=g(8863),v=g(2036),b={Base:class{constructor(u){this.type=u,this.$_root=null,this._definition={},this._reset()}_reset(){this._ids=new o.Ids,this._preferences=null,this._refs=new f.Manager,this._cache=null,this._valids=null,this._invalids=null,this._flags={},this._rules=[],this._singleRules=new Map,this.$_terms={},this.$_temp={ruleset:null,whens:{}}}describe(){return l(typeof s.describe=="function","Manifest functionality disabled"),s.describe(this)}allow(...u){return n.verifyFlat(u,"allow"),this._values(u,"_valids")}alter(u){l(u&&typeof u=="object"&&!Array.isArray(u),"Invalid targets argument"),l(!this._inRuleset(),"Cannot set alterations inside a ruleset");const p=this.clone();p.$_terms.alterations=p.$_terms.alterations||[];for(const h in u){const $=u[h];l(typeof $=="function","Alteration adjuster for",h,"must be a function"),p.$_terms.alterations.push({target:h,adjuster:$})}return p.$_temp.ruleset=!1,p}artifact(u){return l(u!==void 0,"Artifact cannot be undefined"),l(!this._cache,"Cannot set an artifact with a rule cache"),this.$_setFlag("artifact",u)}cast(u){return l(u===!1||typeof u=="string","Invalid to value"),l(u===!1||this._definition.cast[u],"Type",this.type,"does not support casting to",u),this.$_setFlag("cast",u===!1?void 0:u)}default(u,p){return this._default("default",u,p)}description(u){return l(u&&typeof u=="string","Description must be a non-empty string"),this.$_setFlag("description",u)}empty(u){const p=this.clone();return u!==void 0&&(u=p.$_compile(u,{override:!1})),p.$_setFlag("empty",u,{clone:!1})}error(u){return l(u,"Missing error"),l(u instanceof Error||typeof u=="function","Must provide a valid Error object or a function"),this.$_setFlag("error",u)}example(u,p={}){return l(u!==void 0,"Missing example"),n.assertOptions(p,["override"]),this._inner("examples",u,{single:!0,override:p.override})}external(u,p){return typeof u=="object"&&(l(!p,"Cannot combine options with description"),p=u.description,u=u.method),l(typeof u=="function","Method must be a function"),l(p===void 0||p&&typeof p=="string","Description must be a non-empty string"),this._inner("externals",{method:u,description:p},{single:!0})}failover(u,p){return this._default("failover",u,p)}forbidden(){return this.presence("forbidden")}id(u){return u?(l(typeof u=="string","id must be a non-empty string"),l(/^[^\.]+$/.test(u),"id cannot contain period character"),this.$_setFlag("id",u)):this.$_setFlag("id",void 0)}invalid(...u){return this._values(u,"_invalids")}label(u){return l(u&&typeof u=="string","Label name must be a non-empty string"),this.$_setFlag("label",u)}meta(u){return l(u!==void 0,"Meta cannot be undefined"),this._inner("metas",u,{single:!0})}note(...u){l(u.length,"Missing notes");for(const p of u)l(p&&typeof p=="string","Notes must be non-empty strings");return this._inner("notes",u)}only(u=!0){return l(typeof u=="boolean","Invalid mode:",u),this.$_setFlag("only",u)}optional(){return this.presence("optional")}prefs(u){l(u,"Missing preferences"),l(u.context===void 0,"Cannot override context"),l(u.externals===void 0,"Cannot override externals"),l(u.warnings===void 0,"Cannot override warnings"),l(u.debug===void 0,"Cannot override debug"),n.checkPreferences(u);const p=this.clone();return p._preferences=n.preferences(p._preferences,u),p}presence(u){return l(["optional","required","forbidden"].includes(u),"Unknown presence mode",u),this.$_setFlag("presence",u)}raw(u=!0){return this.$_setFlag("result",u?"raw":void 0)}result(u){return l(["raw","strip"].includes(u),"Unknown result mode",u),this.$_setFlag("result",u)}required(){return this.presence("required")}strict(u){const p=this.clone(),h=u!==void 0&&!u;return p._preferences=n.preferences(p._preferences,{convert:h}),p}strip(u=!0){return this.$_setFlag("result",u?"strip":void 0)}tag(...u){l(u.length,"Missing tags");for(const p of u)l(p&&typeof p=="string","Tags must be non-empty strings");return this._inner("tags",u)}unit(u){return l(u&&typeof u=="string","Unit name must be a non-empty string"),this.$_setFlag("unit",u)}valid(...u){n.verifyFlat(u,"valid");const p=this.allow(...u);return p.$_setFlag("only",!!p._valids,{clone:!1}),p}when(u,p){const h=this.clone();h.$_terms.whens||(h.$_terms.whens=[]);const $=c.when(h,u,p);if(!["any","link"].includes(h.type)){const A=$.is?[$]:$.switch;for(const R of A)l(!R.then||R.then.type==="any"||R.then.type===h.type,"Cannot combine",h.type,"with",R.then&&R.then.type),l(!R.otherwise||R.otherwise.type==="any"||R.otherwise.type===h.type,"Cannot combine",h.type,"with",R.otherwise&&R.otherwise.type)}return h.$_terms.whens.push($),h.$_mutateRebuild()}cache(u){l(!this._inRuleset(),"Cannot set caching inside a ruleset"),l(!this._cache,"Cannot override schema cache"),l(this._flags.artifact===void 0,"Cannot cache a rule with an artifact");const p=this.clone();return p._cache=u||e.provider.provision(),p.$_temp.ruleset=!1,p}clone(){const u=Object.create(Object.getPrototypeOf(this));return this._assign(u)}concat(u){l(n.isSchema(u),"Invalid schema object"),l(this.type==="any"||u.type==="any"||u.type===this.type,"Cannot merge type",this.type,"with another type:",u.type),l(!this._inRuleset(),"Cannot concatenate onto a schema with open ruleset"),l(!u._inRuleset(),"Cannot concatenate a schema with open ruleset");let p=this.clone();if(this.type==="any"&&u.type!=="any"){const h=u.clone();for(const $ of Object.keys(p))$!=="type"&&(h[$]=p[$]);p=h}p._ids.concat(u._ids),p._refs.register(u,f.toSibling),p._preferences=p._preferences?n.preferences(p._preferences,u._preferences):u._preferences,p._valids=v.merge(p._valids,u._valids,u._invalids),p._invalids=v.merge(p._invalids,u._invalids,u._valids);for(const h of u._singleRules.keys())p._singleRules.has(h)&&(p._rules=p._rules.filter($=>$.keep||$.name!==h),p._singleRules.delete(h));for(const h of u._rules)u._definition.rules[h.method].multi||p._singleRules.set(h.name,h),p._rules.push(h);if(p._flags.empty&&u._flags.empty){p._flags.empty=p._flags.empty.concat(u._flags.empty);const h=Object.assign({},u._flags);delete h.empty,d(p._flags,h)}else if(u._flags.empty){p._flags.empty=u._flags.empty;const h=Object.assign({},u._flags);delete h.empty,d(p._flags,h)}else d(p._flags,u._flags);for(const h in u.$_terms){const $=u.$_terms[h];$?p.$_terms[h]?p.$_terms[h]=p.$_terms[h].concat($):p.$_terms[h]=$.slice():p.$_terms[h]||(p.$_terms[h]=$)}return this.$_root._tracer&&this.$_root._tracer._combine(p,[this,u]),p.$_mutateRebuild()}extend(u){return l(!u.base,"Cannot extend type with another base"),t.type(this,u)}extract(u){return u=Array.isArray(u)?u:u.split("."),this._ids.reach(u)}fork(u,p){l(!this._inRuleset(),"Cannot fork inside a ruleset");let h=this;for(let $ of[].concat(u))$=Array.isArray($)?$:$.split("."),h=h._ids.fork($,p,h);return h.$_temp.ruleset=!1,h}rule(u){const p=this._definition;n.assertOptions(u,Object.keys(p.modifiers)),l(this.$_temp.ruleset!==!1,"Cannot apply rules to empty ruleset or the last rule added does not support rule properties");const h=this.$_temp.ruleset===null?this._rules.length-1:this.$_temp.ruleset;l(h>=0&&h<this._rules.length,"Cannot apply rules to empty ruleset");const $=this.clone();for(let A=h;A<$._rules.length;++A){const R=$._rules[A],F=_(R);for(const L in u)p.modifiers[L](F,u[L]),l(F.name===R.name,"Cannot change rule name");$._rules[A]=F,$._singleRules.get(F.name)===R&&$._singleRules.set(F.name,F)}return $.$_temp.ruleset=!1,$.$_mutateRebuild()}get ruleset(){l(!this._inRuleset(),"Cannot start a new ruleset without closing the previous one");const u=this.clone();return u.$_temp.ruleset=u._rules.length,u}get $(){return this.ruleset}tailor(u){u=[].concat(u),l(!this._inRuleset(),"Cannot tailor inside a ruleset");let p=this;if(this.$_terms.alterations)for(const{target:h,adjuster:$}of this.$_terms.alterations)u.includes(h)&&(p=$(p),l(n.isSchema(p),"Alteration adjuster for",h,"failed to return a schema object"));return p=p.$_modify({each:h=>h.tailor(u),ref:!1}),p.$_temp.ruleset=!1,p.$_mutateRebuild()}tracer(){return a.location?a.location(this):this}validate(u,p){return m.entry(u,this,p)}validateAsync(u,p){return m.entryAsync(u,this,p)}$_addRule(u){typeof u=="string"&&(u={name:u}),l(u&&typeof u=="object","Invalid options"),l(u.name&&typeof u.name=="string","Invalid rule name");for(const R in u)l(R[0]!=="_","Cannot set private rule properties");const p=Object.assign({},u);p._resolve=[],p.method=p.method||p.name;const h=this._definition.rules[p.method],$=p.args;l(h,"Unknown rule",p.method);const A=this.clone();if($){l(Object.keys($).length===1||Object.keys($).length===this._definition.rules[p.name].args.length,"Invalid rule definition for",this.type,p.name);for(const R in $){let F=$[R];if(F!==void 0){if(h.argsByName){const L=h.argsByName.get(R);if(L.ref&&n.isResolvable(F))p._resolve.push(R),A.$_mutateRegister(F);else if(L.normalize&&(F=L.normalize(F),$[R]=F),L.assert){const V=n.validateArg(F,R,L);l(!V,V,"or reference")}}$[R]=F}else delete $[R]}}return h.multi||(A._ruleRemove(p.name,{clone:!1}),A._singleRules.set(p.name,p)),A.$_temp.ruleset===!1&&(A.$_temp.ruleset=null),h.priority?A._rules.unshift(p):A._rules.push(p),A}$_compile(u,p){return c.schema(this.$_root,u,p)}$_createError(u,p,h,$,A,R={}){const F=R.flags!==!1?this._flags:{},L=R.messages?i.merge(this._definition.messages,R.messages):this._definition.messages;return new r.Report(u,p,h,F,L,$,A)}$_getFlag(u){return this._flags[u]}$_getRule(u){return this._singleRules.get(u)}$_mapLabels(u){return u=Array.isArray(u)?u:u.split("."),this._ids.labels(u)}$_match(u,p,h,$){(h=Object.assign({},h)).abortEarly=!0,h._externals=!1,p.snapshot();const A=!m.validate(u,this,p,h,$).errors;return p.restore(),A}$_modify(u){return n.assertOptions(u,["each","once","ref","schema"]),o.schema(this,u)||this}$_mutateRebuild(){return l(!this._inRuleset(),"Cannot add this rule inside a ruleset"),this._refs.reset(),this._ids.reset(),this.$_modify({each:(u,{source:p,name:h,path:$,key:A})=>{const R=this._definition[p][h]&&this._definition[p][h].register;R!==!1&&this.$_mutateRegister(u,{family:R,key:A})}}),this._definition.rebuild&&this._definition.rebuild(this),this.$_temp.ruleset=!1,this}$_mutateRegister(u,{family:p,key:h}={}){this._refs.register(u,p),this._ids.register(u,{key:h})}$_property(u){return this._definition.properties[u]}$_reach(u){return this._ids.reach(u)}$_rootReferences(){return this._refs.roots()}$_setFlag(u,p,h={}){l(u[0]==="_"||!this._inRuleset(),"Cannot set flag inside a ruleset");const $=this._definition.flags[u]||{};if(y(p,$.default)&&(p=void 0),y(p,this._flags[u]))return this;const A=h.clone!==!1?this.clone():this;return p!==void 0?(A._flags[u]=p,A.$_mutateRegister(p)):delete A._flags[u],u[0]!=="_"&&(A.$_temp.ruleset=!1),A}$_parent(u,...p){return this[u][n.symbols.parent].call(this,...p)}$_validate(u,p,h){return m.validate(u,this,p,h)}_assign(u){u.type=this.type,u.$_root=this.$_root,u.$_temp=Object.assign({},this.$_temp),u.$_temp.whens={},u._ids=this._ids.clone(),u._preferences=this._preferences,u._valids=this._valids&&this._valids.clone(),u._invalids=this._invalids&&this._invalids.clone(),u._rules=this._rules.slice(),u._singleRules=_(this._singleRules,{shallow:!0}),u._refs=this._refs.clone(),u._flags=Object.assign({},this._flags),u._cache=null,u.$_terms={};for(const p in this.$_terms)u.$_terms[p]=this.$_terms[p]?this.$_terms[p].slice():null;u.$_super={};for(const p in this.$_super)u.$_super[p]=this._super[p].bind(u);return u}_bare(){const u=this.clone();u._reset();const p=u._definition.terms;for(const h in p){const $=p[h];u.$_terms[h]=$.init}return u.$_mutateRebuild()}_default(u,p,h={}){return n.assertOptions(h,"literal"),l(p!==void 0,"Missing",u,"value"),l(typeof p=="function"||!h.literal,"Only function value supports literal option"),typeof p=="function"&&h.literal&&(p={[n.symbols.literal]:!0,literal:p}),this.$_setFlag(u,p)}_generate(u,p,h){if(!this.$_terms.whens)return{schema:this};const $=[],A=[];for(let L=0;L<this.$_terms.whens.length;++L){const V=this.$_terms.whens[L];if(V.concat){$.push(V.concat),A.push("".concat(L,".concat"));continue}const W=V.ref?V.ref.resolve(u,p,h):u,K=V.is?[V]:V.switch,ie=A.length;for(let q=0;q<K.length;++q){const{is:B,then:Q,otherwise:ne}=K[q],oe="".concat(L).concat(V.switch?"."+q:"");if(B.$_match(W,p.nest(B,"".concat(oe,".is")),h)){if(Q){const le=p.localize([...p.path,"".concat(oe,".then")],p.ancestors,p.schemas),{schema:ce,id:ue}=Q._generate(u,le,h);$.push(ce),A.push("".concat(oe,".then").concat(ue?"(".concat(ue,")"):""));break}}else if(ne){const le=p.localize([...p.path,"".concat(oe,".otherwise")],p.ancestors,p.schemas),{schema:ce,id:ue}=ne._generate(u,le,h);$.push(ce),A.push("".concat(oe,".otherwise").concat(ue?"(".concat(ue,")"):""));break}}if(V.break&&A.length>ie)break}const R=A.join(", ");if(p.mainstay.tracer.debug(p,"rule","when",R),!R)return{schema:this};if(!p.mainstay.tracer.active&&this.$_temp.whens[R])return{schema:this.$_temp.whens[R],id:R};let F=this;this._definition.generate&&(F=this._definition.generate(this,u,p,h));for(const L of $)F=F.concat(L);return this.$_root._tracer&&this.$_root._tracer._combine(F,[this,...$]),this.$_temp.whens[R]=F,{schema:F,id:R}}_inner(u,p,h={}){l(!this._inRuleset(),"Cannot set ".concat(u," inside a ruleset"));const $=this.clone();return $.$_terms[u]&&!h.override||($.$_terms[u]=[]),h.single?$.$_terms[u].push(p):$.$_terms[u].push(...p),$.$_temp.ruleset=!1,$}_inRuleset(){return this.$_temp.ruleset!==null&&this.$_temp.ruleset!==!1}_ruleRemove(u,p={}){if(!this._singleRules.has(u))return this;const h=p.clone!==!1?this.clone():this;h._singleRules.delete(u);const $=[];for(let A=0;A<h._rules.length;++A){const R=h._rules[A];R.name!==u||R.keep?$.push(R):h._inRuleset()&&A<h.$_temp.ruleset&&--h.$_temp.ruleset}return h._rules=$,h}_values(u,p){n.verifyFlat(u,p.slice(1,-1));const h=this.clone(),$=u[0]===n.symbols.override;if($&&(u=u.slice(1)),!h[p]&&u.length?h[p]=new v:$&&(h[p]=u.length?new v:null,h.$_mutateRebuild()),!h[p])return h;$&&h[p].override();for(const A of u){l(A!==void 0,"Cannot call allow/valid/invalid with undefined"),l(A!==n.symbols.override,"Override must be the first value");const R=p==="_invalids"?"_valids":"_invalids";h[R]&&(h[R].remove(A),h[R].length||(l(p==="_valids"||!h._flags.only,"Setting invalid value",A,"leaves schema rejecting all values due to previous valid rule"),h[R]=null)),h[p].add(A,h._refs)}return h}}};b.Base.prototype[n.symbols.any]={version:n.version,compile:c.compile,root:"$_root"},b.Base.prototype.isImmutable=!0,b.Base.prototype.deny=b.Base.prototype.invalid,b.Base.prototype.disallow=b.Base.prototype.invalid,b.Base.prototype.equal=b.Base.prototype.valid,b.Base.prototype.exist=b.Base.prototype.required,b.Base.prototype.not=b.Base.prototype.invalid,b.Base.prototype.options=b.Base.prototype.prefs,b.Base.prototype.preferences=b.Base.prototype.prefs,O.exports=new b.Base},8652:(O,x,g)=>{const l=g(375),_=g(8571),y=g(8160),d={max:1e3,supported:new Set(["undefined","boolean","number","string"])};x.provider={provision:e=>new d.Cache(e)},d.Cache=class{constructor(e={}){y.assertOptions(e,["max"]),l(e.max===void 0||e.max&&e.max>0&&isFinite(e.max),"Invalid max cache size"),this._max=e.max||d.max,this._map=new Map,this._list=new d.List}get length(){return this._map.size}set(e,n){if(e!==null&&!d.supported.has(typeof e))return;let c=this._map.get(e);if(c)return c.value=n,void this._list.first(c);c=this._list.unshift({key:e,value:n}),this._map.set(e,c),this._compact()}get(e){const n=this._map.get(e);if(n)return this._list.first(n),_(n.value)}_compact(){if(this._map.size>this._max){const e=this._list.pop();this._map.delete(e.key)}}},d.List=class{constructor(){this.tail=null,this.head=null}unshift(e){return e.next=null,e.prev=this.head,this.head&&(this.head.next=e),this.head=e,this.tail||(this.tail=e),e}first(e){e!==this.head&&(this._remove(e),this.unshift(e))}pop(){return this._remove(this.tail)}_remove(e){const{next:n,prev:c}=e;return n.prev=c,c&&(c.next=n),e===this.tail&&(this.tail=n),e.prev=null,e.next=null,e}}},8160:(O,x,g)=>{const l=g(375),_=g(7916),y=g(1238);let d,e;const n={isoDate:/^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/};x.version=y.version,x.defaults={abortEarly:!0,allowUnknown:!1,artifacts:!1,cache:!0,context:null,convert:!0,dateFormat:"iso",errors:{escapeHtml:!1,label:"path",language:null,render:!0,stack:!1,wrap:{label:'"',array:"[]"}},externals:!0,messages:{},nonEnumerables:!1,noDefaults:!1,presence:"optional",skipFunctions:!1,stripUnknown:!1,warnings:!1},x.symbols={any:Symbol.for("@hapi/joi/schema"),arraySingle:Symbol("arraySingle"),deepDefault:Symbol("deepDefault"),errors:Symbol("errors"),literal:Symbol("literal"),override:Symbol("override"),parent:Symbol("parent"),prefs:Symbol("prefs"),ref:Symbol("ref"),template:Symbol("template"),values:Symbol("values")},x.assertOptions=function(c,r,t="Options"){l(c&&typeof c=="object"&&!Array.isArray(c),"Options must be of type object");const s=Object.keys(c).filter(i=>!r.includes(i));l(s.length===0,"".concat(t," contain unknown keys: ").concat(s))},x.checkPreferences=function(c){e=e||g(3378);const r=e.preferences.validate(c);if(r.error)throw new _([r.error.details[0].message])},x.compare=function(c,r,t){switch(t){case"=":return c===r;case">":return c>r;case"<":return c<r;case">=":return c>=r;case"<=":return c<=r}},x.default=function(c,r){return c===void 0?r:c},x.isIsoDate=function(c){return n.isoDate.test(c)},x.isNumber=function(c){return typeof c=="number"&&!isNaN(c)},x.isResolvable=function(c){return!!c&&(c[x.symbols.ref]||c[x.symbols.template])},x.isSchema=function(c,r={}){const t=c&&c[x.symbols.any];return!!t&&(l(r.legacy||t.version===x.version,"Cannot mix different versions of joi schemas"),!0)},x.isValues=function(c){return c[x.symbols.values]},x.limit=function(c){return Number.isSafeInteger(c)&&c>=0},x.preferences=function(c,r){d=d||g(6914),c=c||{},r=r||{};const t=Object.assign({},c,r);return r.errors&&c.errors&&(t.errors=Object.assign({},c.errors,r.errors),t.errors.wrap=Object.assign({},c.errors.wrap,r.errors.wrap)),r.messages&&(t.messages=d.compile(r.messages,c.messages)),delete t[x.symbols.prefs],t},x.tryWithPath=function(c,r,t={}){try{return c()}catch(s){throw s.path!==void 0?s.path=r+"."+s.path:s.path=r,t.append&&(s.message="".concat(s.message," (").concat(s.path,")")),s}},x.validateArg=function(c,r,{assert:t,message:s}){if(x.isSchema(t)){const i=t.validate(c);return i.error?i.error.message:void 0}if(!t(c))return r?"".concat(r," ").concat(s):s},x.verifyFlat=function(c,r){for(const t of c)l(!Array.isArray(t),"Method no longer accepts array arguments:",r)}},3292:(O,x,g)=>{const l=g(375),_=g(8160),y=g(6133),d={};x.schema=function(e,n,c={}){_.assertOptions(c,["appendPath","override"]);try{return d.schema(e,n,c)}catch(r){throw c.appendPath&&r.path!==void 0&&(r.message="".concat(r.message," (").concat(r.path,")")),r}},d.schema=function(e,n,c){l(n!==void 0,"Invalid undefined schema"),Array.isArray(n)&&(l(n.length,"Invalid empty array schema"),n.length===1&&(n=n[0]));const r=(t,...s)=>c.override!==!1?t.valid(e.override,...s):t.valid(...s);if(d.simple(n))return r(e,n);if(typeof n=="function")return e.custom(n);if(l(typeof n=="object","Invalid schema content:",typeof n),_.isResolvable(n))return r(e,n);if(_.isSchema(n))return n;if(Array.isArray(n)){for(const t of n)if(!d.simple(t))return e.alternatives().try(...n);return r(e,...n)}return n instanceof RegExp?e.string().regex(n):n instanceof Date?r(e.date(),n):(l(Object.getPrototypeOf(n)===Object.getPrototypeOf({}),"Schema can only contain plain objects"),e.object().keys(n))},x.ref=function(e,n){return y.isRef(e)?e:y.create(e,n)},x.compile=function(e,n,c={}){_.assertOptions(c,["legacy"]);const r=n&&n[_.symbols.any];if(r)return l(c.legacy||r.version===_.version,"Cannot mix different versions of joi schemas:",r.version,_.version),n;if(typeof n!="object"||!c.legacy)return x.schema(e,n,{appendPath:!0});const t=d.walk(n);return t?t.compile(t.root,n):x.schema(e,n,{appendPath:!0})},d.walk=function(e){if(typeof e!="object")return null;if(Array.isArray(e)){for(const c of e){const r=d.walk(c);if(r)return r}return null}const n=e[_.symbols.any];if(n)return{root:e[n.root],compile:n.compile};l(Object.getPrototypeOf(e)===Object.getPrototypeOf({}),"Schema can only contain plain objects");for(const c in e){const r=d.walk(e[c]);if(r)return r}return null},d.simple=function(e){return e===null||["boolean","string","number"].includes(typeof e)},x.when=function(e,n,c){if(c===void 0&&(l(n&&typeof n=="object","Missing options"),c=n,n=y.create(".")),Array.isArray(c)&&(c={switch:c}),_.assertOptions(c,["is","not","then","otherwise","switch","break"]),_.isSchema(n))return l(c.is===void 0,'"is" can not be used with a schema condition'),l(c.not===void 0,'"not" can not be used with a schema condition'),l(c.switch===void 0,'"switch" can not be used with a schema condition'),d.condition(e,{is:n,then:c.then,otherwise:c.otherwise,break:c.break});if(l(y.isRef(n)||typeof n=="string","Invalid condition:",n),l(c.not===void 0||c.is===void 0,'Cannot combine "is" with "not"'),c.switch===void 0){let t=c;c.not!==void 0&&(t={is:c.not,then:c.otherwise,otherwise:c.then,break:c.break});let s=t.is!==void 0?e.$_compile(t.is):e.$_root.invalid(null,!1,0,"").required();return l(t.then!==void 0||t.otherwise!==void 0,'options must have at least one of "then", "otherwise", or "switch"'),l(t.break===void 0||t.then===void 0||t.otherwise===void 0,"Cannot specify then, otherwise, and break all together"),c.is===void 0||y.isRef(c.is)||_.isSchema(c.is)||(s=s.required()),d.condition(e,{ref:x.ref(n),is:s,then:t.then,otherwise:t.otherwise,break:t.break})}l(Array.isArray(c.switch),'"switch" must be an array'),l(c.is===void 0,'Cannot combine "switch" with "is"'),l(c.not===void 0,'Cannot combine "switch" with "not"'),l(c.then===void 0,'Cannot combine "switch" with "then"');const r={ref:x.ref(n),switch:[],break:c.break};for(let t=0;t<c.switch.length;++t){const s=c.switch[t],i=t===c.switch.length-1;_.assertOptions(s,i?["is","then","otherwise"]:["is","then"]),l(s.is!==void 0,'Switch statement missing "is"'),l(s.then!==void 0,'Switch statement missing "then"');const o={is:e.$_compile(s.is),then:e.$_compile(s.then)};if(y.isRef(s.is)||_.isSchema(s.is)||(o.is=o.is.required()),i){l(c.otherwise===void 0||s.otherwise===void 0,'Cannot specify "otherwise" inside and outside a "switch"');const f=c.otherwise!==void 0?c.otherwise:s.otherwise;f!==void 0&&(l(r.break===void 0,"Cannot specify both otherwise and break"),o.otherwise=e.$_compile(f))}r.switch.push(o)}return r},d.condition=function(e,n){for(const c of["then","otherwise"])n[c]===void 0?delete n[c]:n[c]=e.$_compile(n[c]);return n}},6354:(O,x,g)=>{const l=g(5688),_=g(8160),y=g(3328);x.Report=class{constructor(d,e,n,c,r,t,s){if(this.code=d,this.flags=c,this.messages=r,this.path=t.path,this.prefs=s,this.state=t,this.value=e,this.message=null,this.template=null,this.local=n||{},this.local.label=x.label(this.flags,this.state,this.prefs,this.messages),this.value===void 0||this.local.hasOwnProperty("value")||(this.local.value=this.value),this.path.length){const i=this.path[this.path.length-1];typeof i!="object"&&(this.local.key=i)}}_setTemplate(d){if(this.template=d,!this.flags.label&&this.path.length===0){const e=this._template(this.template,"root");e&&(this.local.label=e)}}toString(){if(this.message)return this.message;const d=this.code;if(!this.prefs.errors.render)return this.code;const e=this._template(this.template)||this._template(this.prefs.messages)||this._template(this.messages);return e===void 0?'Error code "'.concat(d,'" is not defined, your custom type is missing the correct messages definition'):(this.message=e.render(this.value,this.state,this.prefs,this.local,{errors:this.prefs.errors,messages:[this.prefs.messages,this.messages]}),this.prefs.errors.label||(this.message=this.message.replace(/^"" /,"").trim()),this.message)}_template(d,e){return x.template(this.value,d,e||this.code,this.state,this.prefs)}},x.path=function(d){let e="";for(const n of d)typeof n!="object"&&(typeof n=="string"?(e&&(e+="."),e+=n):e+="[".concat(n,"]"));return e},x.template=function(d,e,n,c,r){if(!e)return;if(y.isTemplate(e))return n!=="root"?e:null;let t=r.errors.language;return _.isResolvable(t)&&(t=t.resolve(d,c,r)),t&&e[t]&&e[t][n]!==void 0?e[t][n]:e[n]},x.label=function(d,e,n,c){if(d.label)return d.label;if(!n.errors.label)return"";let r=e.path;return n.errors.label==="key"&&e.path.length>1&&(r=e.path.slice(-1)),x.path(r)||x.template(null,n.messages,"root",e,n)||c&&x.template(null,c,"root",e,n)||"value"},x.process=function(d,e,n){if(!d)return null;const{override:c,message:r,details:t}=x.details(d);if(c)return c;if(n.errors.stack)return new x.ValidationError(r,t,e);const s=Error.stackTraceLimit;Error.stackTraceLimit=0;const i=new x.ValidationError(r,t,e);return Error.stackTraceLimit=s,i},x.details=function(d,e={}){let n=[];const c=[];for(const r of d){if(r instanceof Error){if(e.override!==!1)return{override:r};const s=r.toString();n.push(s),c.push({message:s,type:"override",context:{error:r}});continue}const t=r.toString();n.push(t),c.push({message:t,path:r.path.filter(s=>typeof s!="object"),type:r.code,context:r.local})}return n.length>1&&(n=[...new Set(n)]),{message:n.join(". "),details:c}},x.ValidationError=class extends Error{constructor(d,e,n){super(d),this._original=n,this.details=e}static isError(d){return d instanceof x.ValidationError}},x.ValidationError.prototype.isJoi=!0,x.ValidationError.prototype.name="ValidationError",x.ValidationError.prototype.annotate=l.error},8901:(O,x,g)=>{const l=g(375),_=g(8571),y=g(8160),d=g(6914),e={};x.type=function(n,c){const r=Object.getPrototypeOf(n),t=_(r),s=n._assign(Object.create(t)),i=Object.assign({},c);delete i.base,t._definition=i;const o=r._definition||{};i.messages=d.merge(o.messages,i.messages),i.properties=Object.assign({},o.properties,i.properties),s.type=i.type,i.flags=Object.assign({},o.flags,i.flags);const f=Object.assign({},o.terms);if(i.terms)for(const b in i.terms){const u=i.terms[b];l(s.$_terms[b]===void 0,"Invalid term override for",i.type,b),s.$_terms[b]=u.init,f[b]=u}i.terms=f,i.args||(i.args=o.args),i.prepare=e.prepare(i.prepare,o.prepare),i.coerce&&(typeof i.coerce=="function"&&(i.coerce={method:i.coerce}),i.coerce.from&&!Array.isArray(i.coerce.from)&&(i.coerce={method:i.coerce.method,from:[].concat(i.coerce.from)})),i.coerce=e.coerce(i.coerce,o.coerce),i.validate=e.validate(i.validate,o.validate);const a=Object.assign({},o.rules);if(i.rules)for(const b in i.rules){const u=i.rules[b];l(typeof u=="object","Invalid rule definition for",i.type,b);let p=u.method;if(p===void 0&&(p=function(){return this.$_addRule(b)}),p&&(l(!t[b],"Rule conflict in",i.type,b),t[b]=p),l(!a[b],"Rule conflict in",i.type,b),a[b]=u,u.alias){const h=[].concat(u.alias);for(const $ of h)t[$]=u.method}u.args&&(u.argsByName=new Map,u.args=u.args.map(h=>(typeof h=="string"&&(h={name:h}),l(!u.argsByName.has(h.name),"Duplicated argument name",h.name),y.isSchema(h.assert)&&(h.assert=h.assert.strict().label(h.name)),u.argsByName.set(h.name,h),h)))}i.rules=a;const m=Object.assign({},o.modifiers);if(i.modifiers)for(const b in i.modifiers){l(!t[b],"Rule conflict in",i.type,b);const u=i.modifiers[b];l(typeof u=="function","Invalid modifier definition for",i.type,b);const p=function(h){return this.rule({[b]:h})};t[b]=p,m[b]=u}if(i.modifiers=m,i.overrides){t._super=r,s.$_super={};for(const b in i.overrides)l(r[b],"Cannot override missing",b),i.overrides[b][y.symbols.parent]=r[b],s.$_super[b]=r[b].bind(s);Object.assign(t,i.overrides)}i.cast=Object.assign({},o.cast,i.cast);const v=Object.assign({},o.manifest,i.manifest);return v.build=e.build(i.manifest&&i.manifest.build,o.manifest&&o.manifest.build),i.manifest=v,i.rebuild=e.rebuild(i.rebuild,o.rebuild),s},e.build=function(n,c){return n&&c?function(r,t){return c(n(r,t),t)}:n||c},e.coerce=function(n,c){return n&&c?{from:n.from&&c.from?[...new Set([...n.from,...c.from])]:null,method(r,t){let s;if((!c.from||c.from.includes(typeof r))&&(s=c.method(r,t),s)){if(s.errors||s.value===void 0)return s;r=s.value}if(!n.from||n.from.includes(typeof r)){const i=n.method(r,t);if(i)return i}return s}}:n||c},e.prepare=function(n,c){return n&&c?function(r,t){const s=n(r,t);if(s){if(s.errors||s.value===void 0)return s;r=s.value}return c(r,t)||s}:n||c},e.rebuild=function(n,c){return n&&c?function(r){c(r),n(r)}:n||c},e.validate=function(n,c){return n&&c?function(r,t){const s=c(r,t);if(s){if(s.errors&&(!Array.isArray(s.errors)||s.errors.length))return s;r=s.value}return n(r,t)||s}:n||c}},5107:(O,x,g)=>{const l=g(375),_=g(8571),y=g(8652),d=g(8160),e=g(3292),n=g(6354),c=g(8901),r=g(9708),t=g(6133),s=g(3328),i=g(1152);let o;const f={types:{alternatives:g(4946),any:g(8068),array:g(546),boolean:g(4937),date:g(7500),function:g(390),link:g(8785),number:g(3832),object:g(8966),string:g(7417),symbol:g(8826)},aliases:{alt:"alternatives",bool:"boolean",func:"function"},root:function(){const a={_types:new Set(Object.keys(f.types))};for(const m of a._types)a[m]=function(...v){return l(!v.length||["alternatives","link","object"].includes(m),"The",m,"type does not allow arguments"),f.generate(this,f.types[m],v)};for(const m of["allow","custom","disallow","equal","exist","forbidden","invalid","not","only","optional","options","prefs","preferences","required","strip","valid","when"])a[m]=function(...v){return this.any()[m](...v)};Object.assign(a,f.methods);for(const m in f.aliases){const v=f.aliases[m];a[m]=a[v]}return a.x=a.expression,i.setup&&i.setup(a),a}};f.methods={ValidationError:n.ValidationError,version:d.version,cache:y.provider,assert(a,m,...v){f.assert(a,m,!0,v)},attempt:(a,m,...v)=>f.assert(a,m,!1,v),build(a){return l(typeof r.build=="function","Manifest functionality disabled"),r.build(this,a)},checkPreferences(a){d.checkPreferences(a)},compile(a,m){return e.compile(this,a,m)},defaults(a){l(typeof a=="function","modifier must be a function");const m=Object.assign({},this);for(const v of m._types){const b=a(m[v]());l(d.isSchema(b),"modifier must return a valid schema object"),m[v]=function(...u){return f.generate(this,b,u)}}return m},expression:(...a)=>new s(...a),extend(...a){d.verifyFlat(a,"extend"),o=o||g(3378),l(a.length,"You need to provide at least one extension"),this.assert(a,o.extensions);const m=Object.assign({},this);m._types=new Set(m._types);for(let v of a){typeof v=="function"&&(v=v(m)),this.assert(v,o.extension);const b=f.expandExtension(v,m);for(const u of b){l(m[u.type]===void 0||m._types.has(u.type),"Cannot override name",u.type);const p=u.base||this.any(),h=c.type(p,u);m._types.add(u.type),m[u.type]=function(...$){return f.generate(this,h,$)}}}return m},isError:n.ValidationError.isError,isExpression:s.isTemplate,isRef:t.isRef,isSchema:d.isSchema,in:(...a)=>t.in(...a),override:d.symbols.override,ref:(...a)=>t.create(...a),types(){const a={};for(const m of this._types)a[m]=this[m]();for(const m in f.aliases)a[m]=this[m]();return a}},f.assert=function(a,m,v,b){const u=b[0]instanceof Error||typeof b[0]=="string"?b[0]:null,p=u?b[1]:b[0],h=m.validate(a,d.preferences({errors:{stack:!0}},p||{}));let $=h.error;if(!$)return h.value;if(u instanceof Error)throw u;const A=v&&typeof $.annotate=="function"?$.annotate():$.message;throw $ instanceof n.ValidationError==0&&($=_($)),$.message=u?"".concat(u," ").concat(A):A,$},f.generate=function(a,m,v){return l(a,"Must be invoked on a Joi instance."),m.$_root=a,m._definition.args&&v.length?m._definition.args(m,...v):m},f.expandExtension=function(a,m){if(typeof a.type=="string")return[a];const v=[];for(const b of m._types)if(a.type.test(b)){const u=Object.assign({},a);u.type=b,u.base=m[b](),v.push(u)}return v},O.exports=f.root()},6914:(O,x,g)=>{const l=g(375),_=g(8571),y=g(3328);x.compile=function(d,e){if(typeof d=="string")return l(!e,"Cannot set single message string"),new y(d);if(y.isTemplate(d))return l(!e,"Cannot set single message template"),d;l(typeof d=="object"&&!Array.isArray(d),"Invalid message options"),e=e?_(e):{};for(let n in d){const c=d[n];if(n==="root"||y.isTemplate(c)){e[n]=c;continue}if(typeof c=="string"){e[n]=new y(c);continue}l(typeof c=="object"&&!Array.isArray(c),"Invalid message for",n);const r=n;for(n in e[r]=e[r]||{},c){const t=c[n];n==="root"||y.isTemplate(t)?e[r][n]=t:(l(typeof t=="string","Invalid message for",n,"in",r),e[r][n]=new y(t))}}return e},x.decompile=function(d){const e={};for(let n in d){const c=d[n];if(n==="root"){e[n]=c;continue}if(y.isTemplate(c)){e[n]=c.describe({compact:!0});continue}const r=n;for(n in e[r]={},c){const t=c[n];e[r][n]=n!=="root"?t.describe({compact:!0}):t}}return e},x.merge=function(d,e){if(!d)return x.compile(e);if(!e)return d;if(typeof e=="string")return new y(e);if(y.isTemplate(e))return e;const n=_(d);for(let c in e){const r=e[c];if(c==="root"||y.isTemplate(r)){n[c]=r;continue}if(typeof r=="string"){n[c]=new y(r);continue}l(typeof r=="object"&&!Array.isArray(r),"Invalid message for",c);const t=c;for(c in n[t]=n[t]||{},r){const s=r[c];c==="root"||y.isTemplate(s)?n[t][c]=s:(l(typeof s=="string","Invalid message for",c,"in",t),n[t][c]=new y(s))}}return n}},2294:(O,x,g)=>{function l(r,t){var s=Object.keys(r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(r);t&&(i=i.filter(function(o){return Object.getOwnPropertyDescriptor(r,o).enumerable})),s.push.apply(s,i)}return s}function _(r){for(var t=1;t<arguments.length;t++){var s=arguments[t]!=null?arguments[t]:{};t%2?l(Object(s),!0).forEach(function(i){y(r,i,s[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(s)):l(Object(s)).forEach(function(i){Object.defineProperty(r,i,Object.getOwnPropertyDescriptor(s,i))})}return r}function y(r,t,s){return t in r?Object.defineProperty(r,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):r[t]=s,r}const d=g(375),e=g(8160),n=g(6133),c={};x.Ids=c.Ids=class{constructor(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}clone(){const r=new c.Ids;return r._byId=new Map(this._byId),r._byKey=new Map(this._byKey),r._schemaChain=this._schemaChain,r}concat(r){r._schemaChain&&(this._schemaChain=!0);for(const[t,s]of r._byId.entries())d(!this._byKey.has(t),"Schema id conflicts with existing key:",t),this._byId.set(t,s);for(const[t,s]of r._byKey.entries())d(!this._byId.has(t),"Schema key conflicts with existing id:",t),this._byKey.set(t,s)}fork(r,t,s){const i=this._collect(r);i.push({schema:s});const o=i.shift();let f={id:o.id,schema:t(o.schema)};d(e.isSchema(f.schema),"adjuster function failed to return a joi schema type");for(const a of i)f={id:a.id,schema:c.fork(a.schema,f.id,f.schema)};return f.schema}labels(r,t=[]){const s=r[0],i=this._get(s);if(!i)return[...t,...r].join(".");const o=r.slice(1);return t=[...t,i.schema._flags.label||s],o.length?i.schema._ids.labels(o,t):t.join(".")}reach(r,t=[]){const s=r[0],i=this._get(s);d(i,"Schema does not contain path",[...t,...r].join("."));const o=r.slice(1);return o.length?i.schema._ids.reach(o,[...t,s]):i.schema}register(r,{key:t}={}){if(!r||!e.isSchema(r))return;(r.$_property("schemaChain")||r._ids._schemaChain)&&(this._schemaChain=!0);const s=r._flags.id;if(s){const i=this._byId.get(s);d(!i||i.schema===r,"Cannot add different schemas with the same id:",s),d(!this._byKey.has(s),"Schema id conflicts with existing key:",s),this._byId.set(s,{schema:r,id:s})}t&&(d(!this._byKey.has(t),"Schema already contains key:",t),d(!this._byId.has(t),"Schema key conflicts with existing id:",t),this._byKey.set(t,{schema:r,id:t}))}reset(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}_collect(r,t=[],s=[]){const i=r[0],o=this._get(i);d(o,"Schema does not contain path",[...t,...r].join(".")),s=[o,...s];const f=r.slice(1);return f.length?o.schema._ids._collect(f,[...t,i],s):s}_get(r){return this._byId.get(r)||this._byKey.get(r)}},c.fork=function(r,t,s){const i=x.schema(r,{each:(o,{key:f})=>{if(t===(o._flags.id||f))return s},ref:!1});return i?i.$_mutateRebuild():r},x.schema=function(r,t){let s;for(const i in r._flags){if(i[0]==="_")continue;const o=c.scan(r._flags[i],{source:"flags",name:i},t);o!==void 0&&(s=s||r.clone(),s._flags[i]=o)}for(let i=0;i<r._rules.length;++i){const o=r._rules[i],f=c.scan(o.args,{source:"rules",name:o.name},t);if(f!==void 0){s=s||r.clone();const a=Object.assign({},o);a.args=f,s._rules[i]=a,s._singleRules.get(o.name)===o&&s._singleRules.set(o.name,a)}}for(const i in r.$_terms){if(i[0]==="_")continue;const o=c.scan(r.$_terms[i],{source:"terms",name:i},t);o!==void 0&&(s=s||r.clone(),s.$_terms[i]=o)}return s},c.scan=function(r,t,s,i,o){const f=i||[];if(r===null||typeof r!="object")return;let a;if(Array.isArray(r)){for(let m=0;m<r.length;++m){const v=t.source==="terms"&&t.name==="keys"&&r[m].key,b=c.scan(r[m],t,s,[m,...f],v);b!==void 0&&(a=a||r.slice(),a[m]=b)}return a}if(s.schema!==!1&&e.isSchema(r)||s.ref!==!1&&n.isRef(r)){const m=s.each(r,_(_({},t),{},{path:f,key:o}));return m===r?void 0:m}for(const m in r){if(m[0]==="_")continue;const v=c.scan(r[m],t,s,[m,...f],o);v!==void 0&&(a=a||Object.assign({},r),a[m]=v)}return a}},6133:(O,x,g)=>{function l(s,i){var o=Object.keys(s);if(Object.getOwnPropertySymbols){var f=Object.getOwnPropertySymbols(s);i&&(f=f.filter(function(a){return Object.getOwnPropertyDescriptor(s,a).enumerable})),o.push.apply(o,f)}return o}function _(s){for(var i=1;i<arguments.length;i++){var o=arguments[i]!=null?arguments[i]:{};i%2?l(Object(o),!0).forEach(function(f){y(s,f,o[f])}):Object.getOwnPropertyDescriptors?Object.defineProperties(s,Object.getOwnPropertyDescriptors(o)):l(Object(o)).forEach(function(f){Object.defineProperty(s,f,Object.getOwnPropertyDescriptor(o,f))})}return s}function y(s,i,o){return i in s?Object.defineProperty(s,i,{value:o,enumerable:!0,configurable:!0,writable:!0}):s[i]=o,s}const d=g(375),e=g(8571),n=g(9621),c=g(8160);let r;const t={symbol:Symbol("ref"),defaults:{adjust:null,in:!1,iterables:null,map:null,separator:".",type:"value"}};x.create=function(s,i={}){d(typeof s=="string","Invalid reference key:",s),c.assertOptions(i,["adjust","ancestor","in","iterables","map","prefix","render","separator"]),d(!i.prefix||typeof i.prefix=="object","options.prefix must be of type object");const o=Object.assign({},t.defaults,i);delete o.prefix;const f=o.separator,a=t.context(s,f,i.prefix);if(o.type=a.type,s=a.key,o.type==="value")if(a.root&&(d(!f||s[0]!==f,"Cannot specify relative path with root prefix"),o.ancestor="root",s||(s=null)),f&&f===s)s=null,o.ancestor=0;else if(o.ancestor!==void 0)d(!f||!s||s[0]!==f,"Cannot combine prefix with ancestor option");else{const[m,v]=t.ancestor(s,f);v&&(s=s.slice(v))===""&&(s=null),o.ancestor=m}return o.path=f?s===null?[]:s.split(f):[s],new t.Ref(o)},x.in=function(s,i={}){return x.create(s,_(_({},i),{},{in:!0}))},x.isRef=function(s){return!!s&&!!s[c.symbols.ref]},t.Ref=class{constructor(s){d(typeof s=="object","Invalid reference construction"),c.assertOptions(s,["adjust","ancestor","in","iterables","map","path","render","separator","type","depth","key","root","display"]),d([!1,void 0].includes(s.separator)||typeof s.separator=="string"&&s.separator.length===1,"Invalid separator"),d(!s.adjust||typeof s.adjust=="function","options.adjust must be a function"),d(!s.map||Array.isArray(s.map),"options.map must be an array"),d(!s.map||!s.adjust,"Cannot set both map and adjust options"),Object.assign(this,t.defaults,s),d(this.type==="value"||this.ancestor===void 0,"Non-value references cannot reference ancestors"),Array.isArray(this.map)&&(this.map=new Map(this.map)),this.depth=this.path.length,this.key=this.path.length?this.path.join(this.separator):null,this.root=this.path[0],this.updateDisplay()}resolve(s,i,o,f,a={}){return d(!this.in||a.in,"Invalid in() reference usage"),this.type==="global"?this._resolve(o.context,i,a):this.type==="local"?this._resolve(f,i,a):this.ancestor?this.ancestor==="root"?this._resolve(i.ancestors[i.ancestors.length-1],i,a):(d(this.ancestor<=i.ancestors.length,"Invalid reference exceeds the schema root:",this.display),this._resolve(i.ancestors[this.ancestor-1],i,a)):this._resolve(s,i,a)}_resolve(s,i,o){let f;if(this.type==="value"&&i.mainstay.shadow&&o.shadow!==!1&&(f=i.mainstay.shadow.get(this.absolute(i))),f===void 0&&(f=n(s,this.path,{iterables:this.iterables,functions:!0})),this.adjust&&(f=this.adjust(f)),this.map){const a=this.map.get(f);a!==void 0&&(f=a)}return i.mainstay&&i.mainstay.tracer.resolve(i,this,f),f}toString(){return this.display}absolute(s){return[...s.path.slice(0,-this.ancestor),...this.path]}clone(){return new t.Ref(this)}describe(){const s={path:this.path};this.type!=="value"&&(s.type=this.type),this.separator!=="."&&(s.separator=this.separator),this.type==="value"&&this.ancestor!==1&&(s.ancestor=this.ancestor),this.map&&(s.map=[...this.map]);for(const i of["adjust","iterables","render"])this[i]!==null&&this[i]!==void 0&&(s[i]=this[i]);return this.in!==!1&&(s.in=!0),{ref:s}}updateDisplay(){const s=this.key!==null?this.key:"";if(this.type!=="value")return void(this.display="ref:".concat(this.type,":").concat(s));if(!this.separator)return void(this.display="ref:".concat(s));if(!this.ancestor)return void(this.display="ref:".concat(this.separator).concat(s));if(this.ancestor==="root")return void(this.display="ref:root:".concat(s));if(this.ancestor===1)return void(this.display="ref:".concat(s||".."));const i=new Array(this.ancestor+1).fill(this.separator).join("");this.display="ref:".concat(i).concat(s||"")}},t.Ref.prototype[c.symbols.ref]=!0,x.build=function(s){return(s=Object.assign({},t.defaults,s)).type==="value"&&s.ancestor===void 0&&(s.ancestor=1),new t.Ref(s)},t.context=function(s,i,o={}){if(s=s.trim(),o){const f=o.global===void 0?"$":o.global;if(f!==i&&s.startsWith(f))return{key:s.slice(f.length),type:"global"};const a=o.local===void 0?"#":o.local;if(a!==i&&s.startsWith(a))return{key:s.slice(a.length),type:"local"};const m=o.root===void 0?"/":o.root;if(m!==i&&s.startsWith(m))return{key:s.slice(m.length),type:"value",root:!0}}return{key:s,type:"value"}},t.ancestor=function(s,i){if(!i)return[1,0];if(s[0]!==i)return[1,0];if(s[1]!==i)return[0,1];let o=2;for(;s[o]===i;)++o;return[o-1,o]},x.toSibling=0,x.toParent=1,x.Manager=class{constructor(){this.refs=[]}register(s,i){if(s)if(i=i===void 0?x.toParent:i,Array.isArray(s))for(const o of s)this.register(o,i);else if(c.isSchema(s))for(const o of s._refs.refs)o.ancestor-i>=0&&this.refs.push({ancestor:o.ancestor-i,root:o.root});else x.isRef(s)&&s.type==="value"&&s.ancestor-i>=0&&this.refs.push({ancestor:s.ancestor-i,root:s.root}),r=r||g(3328),r.isTemplate(s)&&this.register(s.refs(),i)}get length(){return this.refs.length}clone(){const s=new x.Manager;return s.refs=e(this.refs),s}reset(){this.refs=[]}roots(){return this.refs.filter(s=>!s.ancestor).map(s=>s.root)}}},3378:(O,x,g)=>{const l=g(5107),_={};_.wrap=l.string().min(1).max(2).allow(!1),x.preferences=l.object({allowUnknown:l.boolean(),abortEarly:l.boolean(),artifacts:l.boolean(),cache:l.boolean(),context:l.object(),convert:l.boolean(),dateFormat:l.valid("date","iso","string","time","utc"),debug:l.boolean(),errors:{escapeHtml:l.boolean(),label:l.valid("path","key",!1),language:[l.string(),l.object().ref()],render:l.boolean(),stack:l.boolean(),wrap:{label:_.wrap,array:_.wrap}},externals:l.boolean(),messages:l.object(),noDefaults:l.boolean(),nonEnumerables:l.boolean(),presence:l.valid("required","optional","forbidden"),skipFunctions:l.boolean(),stripUnknown:l.object({arrays:l.boolean(),objects:l.boolean()}).or("arrays","objects").allow(!0,!1),warnings:l.boolean()}).strict(),_.nameRx=/^[a-zA-Z0-9]\w*$/,_.rule=l.object({alias:l.array().items(l.string().pattern(_.nameRx)).single(),args:l.array().items(l.string(),l.object({name:l.string().pattern(_.nameRx).required(),ref:l.boolean(),assert:l.alternatives([l.function(),l.object().schema()]).conditional("ref",{is:!0,then:l.required()}),normalize:l.function(),message:l.string().when("assert",{is:l.function(),then:l.required()})})),convert:l.boolean(),manifest:l.boolean(),method:l.function().allow(!1),multi:l.boolean(),validate:l.function()}),x.extension=l.object({type:l.alternatives([l.string(),l.object().regex()]).required(),args:l.function(),cast:l.object().pattern(_.nameRx,l.object({from:l.function().maxArity(1).required(),to:l.function().minArity(1).maxArity(2).required()})),base:l.object().schema().when("type",{is:l.object().regex(),then:l.forbidden()}),coerce:[l.function().maxArity(3),l.object({method:l.function().maxArity(3).required(),from:l.array().items(l.string()).single()})],flags:l.object().pattern(_.nameRx,l.object({setter:l.string(),default:l.any()})),manifest:{build:l.function().arity(2)},messages:[l.object(),l.string()],modifiers:l.object().pattern(_.nameRx,l.function().minArity(1).maxArity(2)),overrides:l.object().pattern(_.nameRx,l.function()),prepare:l.function().maxArity(3),rebuild:l.function().arity(1),rules:l.object().pattern(_.nameRx,_.rule),terms:l.object().pattern(_.nameRx,l.object({init:l.array().allow(null).required(),manifest:l.object().pattern(/.+/,[l.valid("schema","single"),l.object({mapped:l.object({from:l.string().required(),to:l.string().required()}).required()})])})),validate:l.function().maxArity(3)}).strict(),x.extensions=l.array().items(l.object(),l.function().arity(1)).strict(),_.desc={buffer:l.object({buffer:l.string()}),func:l.object({function:l.function().required(),options:{literal:!0}}),override:l.object({override:!0}),ref:l.object({ref:l.object({type:l.valid("value","global","local"),path:l.array().required(),separator:l.string().length(1).allow(!1),ancestor:l.number().min(0).integer().allow("root"),map:l.array().items(l.array().length(2)).min(1),adjust:l.function(),iterables:l.boolean(),in:l.boolean(),render:l.boolean()}).required()}),regex:l.object({regex:l.string().min(3)}),special:l.object({special:l.valid("deep").required()}),template:l.object({template:l.string().required(),options:l.object()}),value:l.object({value:l.alternatives([l.object(),l.array()]).required()})},_.desc.entity=l.alternatives([l.array().items(l.link("...")),l.boolean(),l.function(),l.number(),l.string(),_.desc.buffer,_.desc.func,_.desc.ref,_.desc.regex,_.desc.special,_.desc.template,_.desc.value,l.link("/")]),_.desc.values=l.array().items(null,l.boolean(),l.function(),l.number().allow(1/0,-1/0),l.string().allow(""),l.symbol(),_.desc.buffer,_.desc.func,_.desc.override,_.desc.ref,_.desc.regex,_.desc.template,_.desc.value),_.desc.messages=l.object().pattern(/.+/,[l.string(),_.desc.template,l.object().pattern(/.+/,[l.string(),_.desc.template])]),x.description=l.object({type:l.string().required(),flags:l.object({cast:l.string(),default:l.any(),description:l.string(),empty:l.link("/"),failover:_.desc.entity,id:l.string(),label:l.string(),only:!0,presence:["optional","required","forbidden"],result:["raw","strip"],strip:l.boolean(),unit:l.string()}).unknown(),preferences:{allowUnknown:l.boolean(),abortEarly:l.boolean(),artifacts:l.boolean(),cache:l.boolean(),convert:l.boolean(),dateFormat:["date","iso","string","time","utc"],errors:{escapeHtml:l.boolean(),label:["path","key"],language:[l.string(),_.desc.ref],wrap:{label:_.wrap,array:_.wrap}},externals:l.boolean(),messages:_.desc.messages,noDefaults:l.boolean(),nonEnumerables:l.boolean(),presence:["required","optional","forbidden"],skipFunctions:l.boolean(),stripUnknown:l.object({arrays:l.boolean(),objects:l.boolean()}).or("arrays","objects").allow(!0,!1),warnings:l.boolean()},allow:_.desc.values,invalid:_.desc.values,rules:l.array().min(1).items({name:l.string().required(),args:l.object().min(1),keep:l.boolean(),message:[l.string(),_.desc.messages],warn:l.boolean()}),keys:l.object().pattern(/.*/,l.link("/")),link:_.desc.ref}).pattern(/^[a-z]\w*$/,l.any())},493:(O,x,g)=>{const l=g(8571),_=g(9621),y=g(8160),d={value:Symbol("value")};O.exports=d.State=class{constructor(e,n,c){this.path=e,this.ancestors=n,this.mainstay=c.mainstay,this.schemas=c.schemas,this.debug=null}localize(e,n=null,c=null){const r=new d.State(e,n,this);return c&&r.schemas&&(r.schemas=[d.schemas(c),...r.schemas]),r}nest(e,n){const c=new d.State(this.path,this.ancestors,this);return c.schemas=c.schemas&&[d.schemas(e),...c.schemas],c.debug=n,c}shadow(e,n){this.mainstay.shadow=this.mainstay.shadow||new d.Shadow,this.mainstay.shadow.set(this.path,e,n)}snapshot(){this.mainstay.shadow&&(this._snapshot=l(this.mainstay.shadow.node(this.path)))}restore(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0)}},d.schemas=function(e){return y.isSchema(e)?{schema:e}:e},d.Shadow=class{constructor(){this._values=null}set(e,n,c){if(!e.length||c==="strip"&&typeof e[e.length-1]=="number")return;this._values=this._values||new Map;let r=this._values;for(let t=0;t<e.length;++t){const s=e[t];let i=r.get(s);i||(i=new Map,r.set(s,i)),r=i}r[d.value]=n}get(e){const n=this.node(e);if(n)return n[d.value]}node(e){if(this._values)return _(this._values,e,{iterables:!0})}override(e,n){if(!this._values)return;const c=e.slice(0,-1),r=e[e.length-1],t=_(this._values,c,{iterables:!0});n?t.set(r,n):t&&t.delete(r)}}},3328:(O,x,g)=>{function l(i,o){var f=Object.keys(i);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(i);o&&(a=a.filter(function(m){return Object.getOwnPropertyDescriptor(i,m).enumerable})),f.push.apply(f,a)}return f}function _(i,o,f){return o in i?Object.defineProperty(i,o,{value:f,enumerable:!0,configurable:!0,writable:!0}):i[o]=f,i}const y=g(375),d=g(8571),e=g(5277),n=g(1447),c=g(8160),r=g(6354),t=g(6133),s={symbol:Symbol("template"),opens:new Array(1e3).join("\0"),closes:new Array(1e3).join(""),dateFormat:{date:Date.prototype.toDateString,iso:Date.prototype.toISOString,string:Date.prototype.toString,time:Date.prototype.toTimeString,utc:Date.prototype.toUTCString}};O.exports=s.Template=class{constructor(i,o){y(typeof i=="string","Template source must be a string"),y(!i.includes("\0")&&!i.includes(""),"Template source cannot contain reserved control characters"),this.source=i,this.rendered=i,this._template=null,this._settings=d(o),this._parse()}_parse(){if(!this.source.includes("{"))return;const i=s.encode(this.source),o=s.split(i);let f=!1;const a=[],m=o.shift();m&&a.push(m);for(const v of o){const b=v[0]!=="{",u=b?"}":"}}",p=v.indexOf(u);if(p===-1||v[1]==="{"){a.push("{".concat(s.decode(v)));continue}let h=v.slice(b?0:1,p);const $=h[0]===":";$&&(h=h.slice(1));const A=this._ref(s.decode(h),{raw:b,wrapped:$});a.push(A),typeof A!="string"&&(f=!0);const R=v.slice(p+u.length);R&&a.push(s.decode(R))}f?this._template=a:this.rendered=a.join("")}static date(i,o){return s.dateFormat[o.dateFormat].call(i)}describe(i={}){if(!this._settings&&i.compact)return this.source;const o={template:this.source};return this._settings&&(o.options=this._settings),o}static build(i){return new s.Template(i.template,i.options)}isDynamic(){return!!this._template}static isTemplate(i){return!!i&&!!i[c.symbols.template]}refs(){if(!this._template)return;const i=[];for(const o of this._template)typeof o!="string"&&i.push(...o.refs);return i}resolve(i,o,f,a){return this._template&&this._template.length===1?this._part(this._template[0],i,o,f,a,{}):this.render(i,o,f,a)}_part(i,...o){return i.ref?i.ref.resolve(...o):i.formula.evaluate(o)}render(i,o,f,a,m={}){if(!this.isDynamic())return this.rendered;const v=[];for(const b of this._template)if(typeof b=="string")v.push(b);else{const u=this._part(b,i,o,f,a,m),p=s.stringify(u,i,o,f,a,m);if(p!==void 0){const h=b.raw||(m.errors&&m.errors.escapeHtml)===!1?p:e(p);v.push(s.wrap(h,b.wrapped&&f.errors.wrap.label))}}return v.join("")}_ref(i,{raw:o,wrapped:f}){const a=[],m=b=>{const u=t.create(b,this._settings);return a.push(u),p=>u.resolve(...p)};try{var v=new n.Parser(i,{reference:m,functions:s.functions,constants:s.constants})}catch(b){throw b.message='Invalid template variable "'.concat(i,'" fails due to: ').concat(b.message),b}if(v.single){if(v.single.type==="reference"){const b=a[0];return{ref:b,raw:o,refs:a,wrapped:f||b.type==="local"&&b.key==="label"}}return s.stringify(v.single.value)}return{formula:v,raw:o,refs:a}}toString(){return this.source}},s.Template.prototype[c.symbols.template]=!0,s.Template.prototype.isImmutable=!0,s.encode=function(i){return i.replace(/\\(\{+)/g,(o,f)=>s.opens.slice(0,f.length)).replace(/\\(\}+)/g,(o,f)=>s.closes.slice(0,f.length))},s.decode=function(i){return i.replace(/\u0000/g,"{").replace(/\u0001/g,"}")},s.split=function(i){const o=[];let f="";for(let a=0;a<i.length;++a){const m=i[a];if(m==="{"){let v="";for(;a+1<i.length&&i[a+1]==="{";)v+="{",++a;o.push(f),f=v}else f+=m}return o.push(f),o},s.wrap=function(i,o){return o?o.length===1?"".concat(o).concat(i).concat(o):"".concat(o[0]).concat(i).concat(o[1]):i},s.stringify=function(i,o,f,a,m,v){const b=typeof i;let u=!1;if(t.isRef(i)&&i.render&&(u=i.in,i=i.resolve(o,f,a,m,function(h){for(var $=1;$<arguments.length;$++){var A=arguments[$]!=null?arguments[$]:{};$%2?l(Object(A),!0).forEach(function(R){_(h,R,A[R])}):Object.getOwnPropertyDescriptors?Object.defineProperties(h,Object.getOwnPropertyDescriptors(A)):l(Object(A)).forEach(function(R){Object.defineProperty(h,R,Object.getOwnPropertyDescriptor(A,R))})}return h}({in:i.in},v))),i===null)return"null";if(b==="string")return i;if(b==="number"||b==="function"||b==="symbol")return i.toString();if(b!=="object")return JSON.stringify(i);if(i instanceof Date)return s.Template.date(i,a);if(i instanceof Map){const h=[];for(const[$,A]of i.entries())h.push("".concat($.toString()," -> ").concat(A.toString()));i=h}if(!Array.isArray(i))return i.toString();let p="";for(const h of i)p=p+(p.length?", ":"")+s.stringify(h,o,f,a,m,v);return u?p:s.wrap(p,a.errors.wrap.array)},s.constants={true:!0,false:!1,null:null,second:1e3,minute:6e4,hour:36e5,day:864e5},s.functions={if:(i,o,f)=>i?o:f,msg(i){const[o,f,a,m,v]=this,b=v.messages;if(!b)return"";const u=r.template(o,b[0],i,f,a)||r.template(o,b[1],i,f,a);return u?u.render(o,f,a,m,v):""},number:i=>typeof i=="number"?i:typeof i=="string"?parseFloat(i):typeof i=="boolean"?i?1:0:i instanceof Date?i.getTime():null}},4946:(O,x,g)=>{const l=g(375),_=g(1687),y=g(8068),d=g(8160),e=g(3292),n=g(6354),c=g(6133),r={};O.exports=y.extend({type:"alternatives",flags:{match:{default:"any"}},terms:{matches:{init:[],register:c.toSibling}},args:(t,...s)=>s.length===1&&Array.isArray(s[0])?t.try(...s[0]):t.try(...s),validate(t,s){const{schema:i,error:o,state:f,prefs:a}=s;if(i._flags.match){const v=[];for(let b=0;b<i.$_terms.matches.length;++b){const u=i.$_terms.matches[b],p=f.nest(u.schema,"match.".concat(b));p.snapshot();const h=u.schema.$_validate(t,p,a);h.errors?p.restore():v.push(h.value)}return v.length===0?{errors:o("alternatives.any")}:i._flags.match==="one"?v.length===1?{value:v[0]}:{errors:o("alternatives.one")}:v.length!==i.$_terms.matches.length?{errors:o("alternatives.all")}:i.$_terms.matches.reduce((b,u)=>b&&u.schema.type==="object",!0)?{value:v.reduce((b,u)=>_(b,u,{mergeArrays:!1}))}:{value:v[v.length-1]}}const m=[];for(let v=0;v<i.$_terms.matches.length;++v){const b=i.$_terms.matches[v];if(b.schema){const h=f.nest(b.schema,"match.".concat(v));h.snapshot();const $=b.schema.$_validate(t,h,a);if(!$.errors)return $;h.restore(),m.push({schema:b.schema,reports:$.errors});continue}const u=b.ref?b.ref.resolve(t,f,a):t,p=b.is?[b]:b.switch;for(let h=0;h<p.length;++h){const $=p[h],{is:A,then:R,otherwise:F}=$,L="match.".concat(v).concat(b.switch?"."+h:"");if(A.$_match(u,f.nest(A,"".concat(L,".is")),a)){if(R)return R.$_validate(t,f.nest(R,"".concat(L,".then")),a)}else if(F)return F.$_validate(t,f.nest(F,"".concat(L,".otherwise")),a)}}return r.errors(m,s)},rules:{conditional:{method(t,s){l(!this._flags._endedSwitch,"Unreachable condition"),l(!this._flags.match,"Cannot combine match mode",this._flags.match,"with conditional rule"),l(s.break===void 0,"Cannot use break option with alternatives conditional");const i=this.clone(),o=e.when(i,t,s),f=o.is?[o]:o.switch;for(const a of f)if(a.then&&a.otherwise){i.$_setFlag("_endedSwitch",!0,{clone:!1});break}return i.$_terms.matches.push(o),i.$_mutateRebuild()}},match:{method(t){if(l(["any","one","all"].includes(t),"Invalid alternatives match mode",t),t!=="any")for(const s of this.$_terms.matches)l(s.schema,"Cannot combine match mode",t,"with conditional rules");return this.$_setFlag("match",t)}},try:{method(...t){l(t.length,"Missing alternative schemas"),d.verifyFlat(t,"try"),l(!this._flags._endedSwitch,"Unreachable condition");const s=this.clone();for(const i of t)s.$_terms.matches.push({schema:s.$_compile(i)});return s.$_mutateRebuild()}}},overrides:{label(t){return this.$_parent("label",t).$_modify({each:(s,i)=>i.path[0]!=="is"?s.label(t):void 0,ref:!1})}},rebuild(t){t.$_modify({each:s=>{d.isSchema(s)&&s.type==="array"&&t.$_setFlag("_arrayItems",!0,{clone:!1})}})},manifest:{build(t,s){if(s.matches)for(const i of s.matches){const{schema:o,ref:f,is:a,not:m,then:v,otherwise:b}=i;t=o?t.try(o):f?t.conditional(f,{is:a,then:v,not:m,otherwise:b,switch:i.switch}):t.conditional(a,{then:v,otherwise:b})}return t}},messages:{"alternatives.all":"{{#label}} does not match all of the required types","alternatives.any":"{{#label}} does not match any of the allowed types","alternatives.match":"{{#label}} does not match any of the allowed types","alternatives.one":"{{#label}} matches more than one allowed type","alternatives.types":"{{#label}} must be one of {{#types}}"}}),r.errors=function(t,{error:s,state:i}){if(!t.length)return{errors:s("alternatives.any")};if(t.length===1)return{errors:t[0].reports};const o=new Set,f=[];for(const{reports:a,schema:m}of t){if(a.length>1)return r.unmatched(t,s);const v=a[0];if(v instanceof n.Report==0)return r.unmatched(t,s);if(v.state.path.length!==i.path.length){f.push({type:m.type,report:v});continue}if(v.code==="any.only"){for(const p of v.local.valids)o.add(p);continue}const[b,u]=v.code.split(".");u==="base"?o.add(b):f.push({type:m.type,report:v})}return f.length?f.length===1?{errors:f[0].report}:r.unmatched(t,s):{errors:s("alternatives.types",{types:[...o]})}},r.unmatched=function(t,s){const i=[];for(const o of t)i.push(...o.reports);return{errors:s("alternatives.match",n.details(i,{override:!1}))}}},8068:(O,x,g)=>{const l=g(375),_=g(7629),y=g(8160),d=g(6914);O.exports=_.extend({type:"any",flags:{only:{default:!1}},terms:{alterations:{init:null},examples:{init:null},externals:{init:null},metas:{init:[]},notes:{init:[]},shared:{init:null},tags:{init:[]},whens:{init:null}},rules:{custom:{method(e,n){return l(typeof e=="function","Method must be a function"),l(n===void 0||n&&typeof n=="string","Description must be a non-empty string"),this.$_addRule({name:"custom",args:{method:e,description:n}})},validate(e,n,{method:c}){try{return c(e,n)}catch(r){return n.error("any.custom",{error:r})}},args:["method","description"],multi:!0},messages:{method(e){return this.prefs({messages:e})}},shared:{method(e){l(y.isSchema(e)&&e._flags.id,"Schema must be a schema with an id");const n=this.clone();return n.$_terms.shared=n.$_terms.shared||[],n.$_terms.shared.push(e),n.$_mutateRegister(e),n}},warning:{method(e,n){return l(e&&typeof e=="string","Invalid warning code"),this.$_addRule({name:"warning",args:{code:e,local:n},warn:!0})},validate:(e,n,{code:c,local:r})=>n.error(c,r),args:["code","local"],multi:!0}},modifiers:{keep(e,n=!0){e.keep=n},message(e,n){e.message=d.compile(n)},warn(e,n=!0){e.warn=n}},manifest:{build(e,n){for(const c in n){const r=n[c];if(["examples","externals","metas","notes","tags"].includes(c))for(const t of r)e=e[c.slice(0,-1)](t);else if(c!=="alterations")if(c!=="whens"){if(c==="shared")for(const t of r)e=e.shared(t)}else for(const t of r){const{ref:s,is:i,not:o,then:f,otherwise:a,concat:m}=t;e=m?e.concat(m):s?e.when(s,{is:i,not:o,then:f,otherwise:a,switch:t.switch,break:t.break}):e.when(i,{then:f,otherwise:a,break:t.break})}else{const t={};for(const{target:s,adjuster:i}of r)t[s]=i;e=e.alter(t)}}return e}},messages:{"any.custom":"{{#label}} failed custom validation because {{#error.message}}","any.default":"{{#label}} threw an error when running default method","any.failover":"{{#label}} threw an error when running failover method","any.invalid":"{{#label}} contains an invalid value","any.only":'{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',"any.ref":"{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}","any.required":"{{#label}} is required","any.unknown":"{{#label}} is not allowed"}})},546:(O,x,g)=>{const l=g(375),_=g(9474),y=g(9621),d=g(8068),e=g(8160),n=g(3292),c={};O.exports=d.extend({type:"array",flags:{single:{default:!1},sparse:{default:!1}},terms:{items:{init:[],manifest:"schema"},ordered:{init:[],manifest:"schema"},_exclusions:{init:[]},_inclusions:{init:[]},_requireds:{init:[]}},coerce:{from:"object",method(r,{schema:t,state:s,prefs:i}){if(!Array.isArray(r))return;const o=t.$_getRule("sort");return o?c.sort(t,r,o.args.options,s,i):void 0}},validate(r,{schema:t,error:s}){if(!Array.isArray(r)){if(t._flags.single){const i=[r];return i[e.symbols.arraySingle]=!0,{value:i}}return{errors:s("array.base")}}if(t.$_getRule("items")||t.$_terms.externals)return{value:r.slice()}},rules:{has:{method(r){r=this.$_compile(r,{appendPath:!0});const t=this.$_addRule({name:"has",args:{schema:r}});return t.$_mutateRegister(r),t},validate(r,{state:t,prefs:s,error:i},{schema:o}){const f=[r,...t.ancestors];for(let m=0;m<r.length;++m){const v=t.localize([...t.path,m],f,o);if(o.$_match(r[m],v,s))return r}const a=o._flags.label;return a?i("array.hasKnown",{patternLabel:a}):i("array.hasUnknown",null)},multi:!0},items:{method(...r){e.verifyFlat(r,"items");const t=this.$_addRule("items");for(let s=0;s<r.length;++s){const i=e.tryWithPath(()=>this.$_compile(r[s]),s,{append:!0});t.$_terms.items.push(i)}return t.$_mutateRebuild()},validate(r,{schema:t,error:s,state:i,prefs:o,errorsArray:f}){const a=t.$_terms._requireds.slice(),m=t.$_terms.ordered.slice(),v=[...t.$_terms._inclusions,...a],b=!r[e.symbols.arraySingle];delete r[e.symbols.arraySingle];const u=f();let p=r.length;for(let h=0;h<p;++h){const $=r[h];let A=!1,R=!1;const F=b?h:new Number(h),L=[...i.path,F];if(!t._flags.sparse&&$===void 0){if(u.push(s("array.sparse",{key:F,path:L,pos:h,value:void 0},i.localize(L))),o.abortEarly)return u;m.shift();continue}const V=[r,...i.ancestors];for(const q of t.$_terms._exclusions)if(q.$_match($,i.localize(L,V,q),o,{presence:"ignore"})){if(u.push(s("array.excludes",{pos:h,value:$},i.localize(L))),o.abortEarly)return u;A=!0,m.shift();break}if(A)continue;if(t.$_terms.ordered.length){if(m.length){const q=m.shift(),B=q.$_validate($,i.localize(L,V,q),o);if(B.errors){if(u.push(...B.errors),o.abortEarly)return u}else if(q._flags.result==="strip")c.fastSplice(r,h),--h,--p;else{if(!t._flags.sparse&&B.value===void 0){if(u.push(s("array.sparse",{key:F,path:L,pos:h,value:void 0},i.localize(L))),o.abortEarly)return u;continue}r[h]=B.value}continue}if(!t.$_terms.items.length){if(u.push(s("array.orderedLength",{pos:h,limit:t.$_terms.ordered.length})),o.abortEarly)return u;break}}const W=[];let K=a.length;for(let q=0;q<K;++q){const B=i.localize(L,V,a[q]);B.snapshot();const Q=a[q].$_validate($,B,o);if(W[q]=Q,!Q.errors){if(r[h]=Q.value,R=!0,c.fastSplice(a,q),--q,--K,!t._flags.sparse&&Q.value===void 0&&(u.push(s("array.sparse",{key:F,path:L,pos:h,value:void 0},i.localize(L))),o.abortEarly))return u;break}B.restore()}if(R)continue;const ie=o.stripUnknown&&!!o.stripUnknown.arrays||!1;K=v.length;for(const q of v){let B;const Q=a.indexOf(q);if(Q!==-1)B=W[Q];else{const ne=i.localize(L,V,q);if(ne.snapshot(),B=q.$_validate($,ne,o),!B.errors){q._flags.result==="strip"?(c.fastSplice(r,h),--h,--p):t._flags.sparse||B.value!==void 0?r[h]=B.value:(u.push(s("array.sparse",{key:F,path:L,pos:h,value:void 0},i.localize(L))),A=!0),R=!0;break}ne.restore()}if(K===1){if(ie){c.fastSplice(r,h),--h,--p,R=!0;break}if(u.push(...B.errors),o.abortEarly)return u;A=!0;break}}if(!A&&(t.$_terms._inclusions.length||t.$_terms._requireds.length)&&!R){if(ie){c.fastSplice(r,h),--h,--p;continue}if(u.push(s("array.includes",{pos:h,value:$},i.localize(L))),o.abortEarly)return u}}return a.length&&c.fillMissedErrors(t,u,a,r,i,o),m.length&&(c.fillOrderedErrors(t,u,m,r,i,o),u.length||c.fillDefault(m,r,i,o)),u.length?u:r},priority:!0,manifest:!1},length:{method(r){return this.$_addRule({name:"length",args:{limit:r},operator:"="})},validate:(r,t,{limit:s},{name:i,operator:o,args:f})=>e.compare(r.length,s,o)?r:t.error("array."+i,{limit:f.limit,value:r}),args:[{name:"limit",ref:!0,assert:e.limit,message:"must be a positive integer"}]},max:{method(r){return this.$_addRule({name:"max",method:"length",args:{limit:r},operator:"<="})}},min:{method(r){return this.$_addRule({name:"min",method:"length",args:{limit:r},operator:">="})}},ordered:{method(...r){e.verifyFlat(r,"ordered");const t=this.$_addRule("items");for(let s=0;s<r.length;++s){const i=e.tryWithPath(()=>this.$_compile(r[s]),s,{append:!0});c.validateSingle(i,t),t.$_mutateRegister(i),t.$_terms.ordered.push(i)}return t.$_mutateRebuild()}},single:{method(r){const t=r===void 0||!!r;return l(!t||!this._flags._arrayItems,"Cannot specify single rule when array has array items"),this.$_setFlag("single",t)}},sort:{method(r={}){e.assertOptions(r,["by","order"]);const t={order:r.order||"ascending"};return r.by&&(t.by=n.ref(r.by,{ancestor:0}),l(!t.by.ancestor,"Cannot sort by ancestor")),this.$_addRule({name:"sort",args:{options:t}})},validate(r,{error:t,state:s,prefs:i,schema:o},{options:f}){const{value:a,errors:m}=c.sort(o,r,f,s,i);if(m)return m;for(let v=0;v<r.length;++v)if(r[v]!==a[v])return t("array.sort",{order:f.order,by:f.by?f.by.key:"value"});return r},convert:!0},sparse:{method(r){const t=r===void 0||!!r;return this._flags.sparse===t?this:(t?this.clone():this.$_addRule("items")).$_setFlag("sparse",t,{clone:!1})}},unique:{method(r,t={}){l(!r||typeof r=="function"||typeof r=="string","comparator must be a function or a string"),e.assertOptions(t,["ignoreUndefined","separator"]);const s={name:"unique",args:{options:t,comparator:r}};if(r)if(typeof r=="string"){const i=e.default(t.separator,".");s.path=i?r.split(i):[r]}else s.comparator=r;return this.$_addRule(s)},validate(r,{state:t,error:s,schema:i},{comparator:o,options:f},{comparator:a,path:m}){const v={string:Object.create(null),number:Object.create(null),undefined:Object.create(null),boolean:Object.create(null),object:new Map,function:new Map,custom:new Map},b=a||_,u=f.ignoreUndefined;for(let p=0;p<r.length;++p){const h=m?y(r[p],m):r[p],$=a?v.custom:v[typeof h];if(l($,"Failed to find unique map container for type",typeof h),$ instanceof Map){const A=$.entries();let R;for(;!(R=A.next()).done;)if(b(R.value[0],h)){const F=t.localize([...t.path,p],[r,...t.ancestors]),L={pos:p,value:r[p],dupePos:R.value[1],dupeValue:r[R.value[1]]};return m&&(L.path=o),s("array.unique",L,F)}$.set(h,p)}else{if((!u||h!==void 0)&&$[h]!==void 0){const A={pos:p,value:r[p],dupePos:$[h],dupeValue:r[$[h]]};return m&&(A.path=o),s("array.unique",A,t.localize([...t.path,p],[r,...t.ancestors]))}$[h]=p}}return r},args:["comparator","options"],multi:!0}},cast:{set:{from:Array.isArray,to:(r,t)=>new Set(r)}},rebuild(r){r.$_terms._inclusions=[],r.$_terms._exclusions=[],r.$_terms._requireds=[];for(const t of r.$_terms.items)c.validateSingle(t,r),t._flags.presence==="required"?r.$_terms._requireds.push(t):t._flags.presence==="forbidden"?r.$_terms._exclusions.push(t):r.$_terms._inclusions.push(t);for(const t of r.$_terms.ordered)c.validateSingle(t,r)},manifest:{build:(r,t)=>(t.items&&(r=r.items(...t.items)),t.ordered&&(r=r.ordered(...t.ordered)),r)},messages:{"array.base":"{{#label}} must be an array","array.excludes":"{{#label}} contains an excluded value","array.hasKnown":"{{#label}} does not contain at least one required match for type {:#patternLabel}","array.hasUnknown":"{{#label}} does not contain at least one required match","array.includes":"{{#label}} does not match any of the allowed types","array.includesRequiredBoth":"{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)","array.includesRequiredKnowns":"{{#label}} does not contain {{#knownMisses}}","array.includesRequiredUnknowns":"{{#label}} does not contain {{#unknownMisses}} required value(s)","array.length":"{{#label}} must contain {{#limit}} items","array.max":"{{#label}} must contain less than or equal to {{#limit}} items","array.min":"{{#label}} must contain at least {{#limit}} items","array.orderedLength":"{{#label}} must contain at most {{#limit}} items","array.sort":"{{#label}} must be sorted in {#order} order by {{#by}}","array.sort.mismatching":"{{#label}} cannot be sorted due to mismatching types","array.sort.unsupported":"{{#label}} cannot be sorted due to unsupported type {#type}","array.sparse":"{{#label}} must not be a sparse array item","array.unique":"{{#label}} contains a duplicate value"}}),c.fillMissedErrors=function(r,t,s,i,o,f){const a=[];let m=0;for(const v of s){const b=v._flags.label;b?a.push(b):++m}a.length?m?t.push(r.$_createError("array.includesRequiredBoth",i,{knownMisses:a,unknownMisses:m},o,f)):t.push(r.$_createError("array.includesRequiredKnowns",i,{knownMisses:a},o,f)):t.push(r.$_createError("array.includesRequiredUnknowns",i,{unknownMisses:m},o,f))},c.fillOrderedErrors=function(r,t,s,i,o,f){const a=[];for(const m of s)m._flags.presence==="required"&&a.push(m);a.length&&c.fillMissedErrors(r,t,a,i,o,f)},c.fillDefault=function(r,t,s,i){const o=[];let f=!0;for(let a=r.length-1;a>=0;--a){const m=r[a],v=[t,...s.ancestors],b=m.$_validate(void 0,s.localize(s.path,v,m),i).value;if(f){if(b===void 0)continue;f=!1}o.unshift(b)}o.length&&t.push(...o)},c.fastSplice=function(r,t){let s=t;for(;s<r.length;)r[s++]=r[s];--r.length},c.validateSingle=function(r,t){(r.type==="array"||r._flags._arrayItems)&&(l(!t._flags.single,"Cannot specify array item with single rule enabled"),t.$_setFlag("_arrayItems",!0,{clone:!1}))},c.sort=function(r,t,s,i,o){const f=s.order==="ascending"?1:-1,a=-1*f,m=f,v=(b,u)=>{let p=c.compare(b,u,a,m);if(p!==null||(s.by&&(b=s.by.resolve(b,i,o),u=s.by.resolve(u,i,o)),p=c.compare(b,u,a,m),p!==null))return p;const h=typeof b;if(h!==typeof u)throw r.$_createError("array.sort.mismatching",t,null,i,o);if(h!=="number"&&h!=="string")throw r.$_createError("array.sort.unsupported",t,{type:h},i,o);return h==="number"?(b-u)*f:b<u?a:m};try{return{value:t.slice().sort(v)}}catch(b){return{errors:b}}},c.compare=function(r,t,s,i){return r===t?0:r===void 0?1:t===void 0?-1:r===null?i:t===null?s:null}},4937:(O,x,g)=>{const l=g(375),_=g(8068),y=g(8160),d=g(2036),e={isBool:function(n){return typeof n=="boolean"}};O.exports=_.extend({type:"boolean",flags:{sensitive:{default:!1}},terms:{falsy:{init:null,manifest:"values"},truthy:{init:null,manifest:"values"}},coerce(n,{schema:c}){if(typeof n!="boolean"){if(typeof n=="string"){const r=c._flags.sensitive?n:n.toLowerCase();n=r==="true"||r!=="false"&&n}return typeof n!="boolean"&&(n=c.$_terms.truthy&&c.$_terms.truthy.has(n,null,null,!c._flags.sensitive)||(!c.$_terms.falsy||!c.$_terms.falsy.has(n,null,null,!c._flags.sensitive))&&n),{value:n}}},validate(n,{error:c}){if(typeof n!="boolean")return{value:n,errors:c("boolean.base")}},rules:{truthy:{method(...n){y.verifyFlat(n,"truthy");const c=this.clone();c.$_terms.truthy=c.$_terms.truthy||new d;for(let r=0;r<n.length;++r){const t=n[r];l(t!==void 0,"Cannot call truthy with undefined"),c.$_terms.truthy.add(t)}return c}},falsy:{method(...n){y.verifyFlat(n,"falsy");const c=this.clone();c.$_terms.falsy=c.$_terms.falsy||new d;for(let r=0;r<n.length;++r){const t=n[r];l(t!==void 0,"Cannot call falsy with undefined"),c.$_terms.falsy.add(t)}return c}},sensitive:{method(n=!0){return this.$_setFlag("sensitive",n)}}},cast:{number:{from:e.isBool,to:(n,c)=>n?1:0},string:{from:e.isBool,to:(n,c)=>n?"true":"false"}},manifest:{build:(n,c)=>(c.truthy&&(n=n.truthy(...c.truthy)),c.falsy&&(n=n.falsy(...c.falsy)),n)},messages:{"boolean.base":"{{#label}} must be a boolean"}})},7500:(O,x,g)=>{const l=g(375),_=g(8068),y=g(8160),d=g(3328),e={isDate:function(n){return n instanceof Date}};O.exports=_.extend({type:"date",coerce:{from:["number","string"],method:(n,{schema:c})=>({value:e.parse(n,c._flags.format)||n})},validate(n,{schema:c,error:r,prefs:t}){if(n instanceof Date&&!isNaN(n.getTime()))return;const s=c._flags.format;return t.convert&&s&&typeof n=="string"?{value:n,errors:r("date.format",{format:s})}:{value:n,errors:r("date.base")}},rules:{compare:{method:!1,validate(n,c,{date:r},{name:t,operator:s,args:i}){const o=r==="now"?Date.now():r.getTime();return y.compare(n.getTime(),o,s)?n:c.error("date."+t,{limit:i.date,value:n})},args:[{name:"date",ref:!0,normalize:n=>n==="now"?n:e.parse(n),assert:n=>n!==null,message:"must have a valid date format"}]},format:{method(n){return l(["iso","javascript","unix"].includes(n),"Unknown date format",n),this.$_setFlag("format",n)}},greater:{method(n){return this.$_addRule({name:"greater",method:"compare",args:{date:n},operator:">"})}},iso:{method(){return this.format("iso")}},less:{method(n){return this.$_addRule({name:"less",method:"compare",args:{date:n},operator:"<"})}},max:{method(n){return this.$_addRule({name:"max",method:"compare",args:{date:n},operator:"<="})}},min:{method(n){return this.$_addRule({name:"min",method:"compare",args:{date:n},operator:">="})}},timestamp:{method(n="javascript"){return l(["javascript","unix"].includes(n),'"type" must be one of "javascript, unix"'),this.format(n)}}},cast:{number:{from:e.isDate,to:(n,c)=>n.getTime()},string:{from:e.isDate,to:(n,{prefs:c})=>d.date(n,c)}},messages:{"date.base":"{{#label}} must be a valid date","date.format":'{{#label}} must be in {msg("date.format." + #format) || #format} format',"date.greater":"{{#label}} must be greater than {{:#limit}}","date.less":"{{#label}} must be less than {{:#limit}}","date.max":"{{#label}} must be less than or equal to {{:#limit}}","date.min":"{{#label}} must be greater than or equal to {{:#limit}}","date.format.iso":"ISO 8601 date","date.format.javascript":"timestamp or number of milliseconds","date.format.unix":"timestamp or number of seconds"}}),e.parse=function(n,c){if(n instanceof Date)return n;if(typeof n!="string"&&(isNaN(n)||!isFinite(n))||/^\s*$/.test(n))return null;if(c==="iso")return y.isIsoDate(n)?e.date(n.toString()):null;const r=n;if(typeof n=="string"&&/^[+-]?\d+(\.\d+)?$/.test(n)&&(n=parseFloat(n)),c){if(c==="javascript")return e.date(1*n);if(c==="unix")return e.date(1e3*n);if(typeof r=="string")return null}return e.date(n)},e.date=function(n){const c=new Date(n);return isNaN(c.getTime())?null:c}},390:(O,x,g)=>{const l=g(375),_=g(7824);O.exports=_.extend({type:"function",properties:{typeof:"function"},rules:{arity:{method(y){return l(Number.isSafeInteger(y)&&y>=0,"n must be a positive integer"),this.$_addRule({name:"arity",args:{n:y}})},validate:(y,d,{n:e})=>y.length===e?y:d.error("function.arity",{n:e})},class:{method(){return this.$_addRule("class")},validate:(y,d)=>/^\s*class\s/.test(y.toString())?y:d.error("function.class",{value:y})},minArity:{method(y){return l(Number.isSafeInteger(y)&&y>0,"n must be a strict positive integer"),this.$_addRule({name:"minArity",args:{n:y}})},validate:(y,d,{n:e})=>y.length>=e?y:d.error("function.minArity",{n:e})},maxArity:{method(y){return l(Number.isSafeInteger(y)&&y>=0,"n must be a positive integer"),this.$_addRule({name:"maxArity",args:{n:y}})},validate:(y,d,{n:e})=>y.length<=e?y:d.error("function.maxArity",{n:e})}},messages:{"function.arity":"{{#label}} must have an arity of {{#n}}","function.class":"{{#label}} must be a class","function.maxArity":"{{#label}} must have an arity lesser or equal to {{#n}}","function.minArity":"{{#label}} must have an arity greater or equal to {{#n}}"}})},7824:(O,x,g)=>{const l=g(978),_=g(375),y=g(8571),d=g(3652),e=g(8068),n=g(8160),c=g(3292),r=g(6354),t=g(6133),s=g(3328),i={renameDefaults:{alias:!1,multiple:!1,override:!1}};O.exports=e.extend({type:"_keys",properties:{typeof:"object"},flags:{unknown:{default:!1}},terms:{dependencies:{init:null},keys:{init:null,manifest:{mapped:{from:"schema",to:"key"}}},patterns:{init:null},renames:{init:null}},args:(o,f)=>o.keys(f),validate(o,{schema:f,error:a,state:m,prefs:v}){if(!o||typeof o!==f.$_property("typeof")||Array.isArray(o))return{value:o,errors:a("object.base",{type:f.$_property("typeof")})};if(!(f.$_terms.renames||f.$_terms.dependencies||f.$_terms.keys||f.$_terms.patterns||f.$_terms.externals))return;o=i.clone(o,v);const b=[];if(f.$_terms.renames&&!i.rename(f,o,m,v,b))return{value:o,errors:b};if(!f.$_terms.keys&&!f.$_terms.patterns&&!f.$_terms.dependencies)return{value:o,errors:b};const u=new Set(Object.keys(o));if(f.$_terms.keys){const p=[o,...m.ancestors];for(const h of f.$_terms.keys){const $=h.key,A=o[$];u.delete($);const R=m.localize([...m.path,$],p,h),F=h.schema.$_validate(A,R,v);if(F.errors){if(v.abortEarly)return{value:o,errors:F.errors};F.value!==void 0&&(o[$]=F.value),b.push(...F.errors)}else h.schema._flags.result==="strip"||F.value===void 0&&A!==void 0?delete o[$]:F.value!==void 0&&(o[$]=F.value)}}if(u.size||f._flags._hasPatternMatch){const p=i.unknown(f,o,u,b,m,v);if(p)return p}if(f.$_terms.dependencies)for(const p of f.$_terms.dependencies){if(p.key&&p.key.resolve(o,m,v,null,{shadow:!1})===void 0)continue;const h=i.dependencies[p.rel](f,p,o,m,v);if(h){const $=f.$_createError(h.code,o,h.context,m,v);if(v.abortEarly)return{value:o,errors:$};b.push($)}}return{value:o,errors:b}},rules:{and:{method(...o){return n.verifyFlat(o,"and"),i.dependency(this,"and",null,o)}},append:{method(o){return o==null||Object.keys(o).length===0?this:this.keys(o)}},assert:{method(o,f,a){s.isTemplate(o)||(o=c.ref(o)),_(a===void 0||typeof a=="string","Message must be a string"),f=this.$_compile(f,{appendPath:!0});const m=this.$_addRule({name:"assert",args:{subject:o,schema:f,message:a}});return m.$_mutateRegister(o),m.$_mutateRegister(f),m},validate(o,{error:f,prefs:a,state:m},{subject:v,schema:b,message:u}){const p=v.resolve(o,m,a),h=t.isRef(v)?v.absolute(m):[];return b.$_match(p,m.localize(h,[o,...m.ancestors],b),a)?o:f("object.assert",{subject:v,message:u})},args:["subject","schema","message"],multi:!0},instance:{method(o,f){return _(typeof o=="function","constructor must be a function"),f=f||o.name,this.$_addRule({name:"instance",args:{constructor:o,name:f}})},validate:(o,f,{constructor:a,name:m})=>o instanceof a?o:f.error("object.instance",{type:m,value:o}),args:["constructor","name"]},keys:{method(o){_(o===void 0||typeof o=="object","Object schema must be a valid object"),_(!n.isSchema(o),"Object schema cannot be a joi schema");const f=this.clone();if(o)if(Object.keys(o).length){f.$_terms.keys=f.$_terms.keys?f.$_terms.keys.filter(a=>!o.hasOwnProperty(a.key)):new i.Keys;for(const a in o)n.tryWithPath(()=>f.$_terms.keys.push({key:a,schema:this.$_compile(o[a])}),a)}else f.$_terms.keys=new i.Keys;else f.$_terms.keys=null;return f.$_mutateRebuild()}},length:{method(o){return this.$_addRule({name:"length",args:{limit:o},operator:"="})},validate:(o,f,{limit:a},{name:m,operator:v,args:b})=>n.compare(Object.keys(o).length,a,v)?o:f.error("object."+m,{limit:b.limit,value:o}),args:[{name:"limit",ref:!0,assert:n.limit,message:"must be a positive integer"}]},max:{method(o){return this.$_addRule({name:"max",method:"length",args:{limit:o},operator:"<="})}},min:{method(o){return this.$_addRule({name:"min",method:"length",args:{limit:o},operator:">="})}},nand:{method(...o){return n.verifyFlat(o,"nand"),i.dependency(this,"nand",null,o)}},or:{method(...o){return n.verifyFlat(o,"or"),i.dependency(this,"or",null,o)}},oxor:{method(...o){return i.dependency(this,"oxor",null,o)}},pattern:{method(o,f,a={}){const m=o instanceof RegExp;m||(o=this.$_compile(o,{appendPath:!0})),_(f!==void 0,"Invalid rule"),n.assertOptions(a,["fallthrough","matches"]),m&&_(!o.flags.includes("g")&&!o.flags.includes("y"),"pattern should not use global or sticky mode"),f=this.$_compile(f,{appendPath:!0});const v=this.clone();v.$_terms.patterns=v.$_terms.patterns||[];const b={[m?"regex":"schema"]:o,rule:f};return a.matches&&(b.matches=this.$_compile(a.matches),b.matches.type!=="array"&&(b.matches=b.matches.$_root.array().items(b.matches)),v.$_mutateRegister(b.matches),v.$_setFlag("_hasPatternMatch",!0,{clone:!1})),a.fallthrough&&(b.fallthrough=!0),v.$_terms.patterns.push(b),v.$_mutateRegister(f),v}},ref:{method(){return this.$_addRule("ref")},validate:(o,f)=>t.isRef(o)?o:f.error("object.refType",{value:o})},regex:{method(){return this.$_addRule("regex")},validate:(o,f)=>o instanceof RegExp?o:f.error("object.regex",{value:o})},rename:{method(o,f,a={}){_(typeof o=="string"||o instanceof RegExp,"Rename missing the from argument"),_(typeof f=="string"||f instanceof s,"Invalid rename to argument"),_(f!==o,"Cannot rename key to same name:",o),n.assertOptions(a,["alias","ignoreUndefined","override","multiple"]);const m=this.clone();m.$_terms.renames=m.$_terms.renames||[];for(const v of m.$_terms.renames)_(v.from!==o,"Cannot rename the same key multiple times");return f instanceof s&&m.$_mutateRegister(f),m.$_terms.renames.push({from:o,to:f,options:l(i.renameDefaults,a)}),m}},schema:{method(o="any"){return this.$_addRule({name:"schema",args:{type:o}})},validate:(o,f,{type:a})=>!n.isSchema(o)||a!=="any"&&o.type!==a?f.error("object.schema",{type:a}):o},unknown:{method(o){return this.$_setFlag("unknown",o!==!1)}},with:{method(o,f,a={}){return i.dependency(this,"with",o,f,a)}},without:{method(o,f,a={}){return i.dependency(this,"without",o,f,a)}},xor:{method(...o){return n.verifyFlat(o,"xor"),i.dependency(this,"xor",null,o)}}},overrides:{default(o,f){return o===void 0&&(o=n.symbols.deepDefault),this.$_parent("default",o,f)}},rebuild(o){if(o.$_terms.keys){const f=new d.Sorter;for(const a of o.$_terms.keys)n.tryWithPath(()=>f.add(a,{after:a.schema.$_rootReferences(),group:a.key}),a.key);o.$_terms.keys=new i.Keys(...f.nodes)}},manifest:{build(o,f){if(f.keys&&(o=o.keys(f.keys)),f.dependencies)for(const{rel:a,key:m=null,peers:v,options:b}of f.dependencies)o=i.dependency(o,a,m,v,b);if(f.patterns)for(const{regex:a,schema:m,rule:v,fallthrough:b,matches:u}of f.patterns)o=o.pattern(a||m,v,{fallthrough:b,matches:u});if(f.renames)for(const{from:a,to:m,options:v}of f.renames)o=o.rename(a,m,v);return o}},messages:{"object.and":"{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}","object.assert":'{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',"object.base":"{{#label}} must be of type {{#type}}","object.instance":"{{#label}} must be an instance of {{:#type}}","object.length":'{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',"object.max":'{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',"object.min":'{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',"object.missing":"{{#label}} must contain at least one of {{#peersWithLabels}}","object.nand":"{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}","object.oxor":"{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}","object.pattern.match":"{{#label}} keys failed to match pattern requirements","object.refType":"{{#label}} must be a Joi reference","object.regex":"{{#label}} must be a RegExp object","object.rename.multiple":"{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}","object.rename.override":"{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists","object.schema":"{{#label}} must be a Joi schema of {{#type}} type","object.unknown":"{{#label}} is not allowed","object.with":"{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}","object.without":"{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}","object.xor":"{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"}}),i.clone=function(o,f){if(typeof o=="object"){if(f.nonEnumerables)return y(o,{shallow:!0});const m=Object.create(Object.getPrototypeOf(o));return Object.assign(m,o),m}const a=function(...m){return o.apply(this,m)};return a.prototype=y(o.prototype),Object.defineProperty(a,"name",{value:o.name,writable:!1}),Object.defineProperty(a,"length",{value:o.length,writable:!1}),Object.assign(a,o),a},i.dependency=function(o,f,a,m,v){_(a===null||typeof a=="string",f,"key must be a strings"),v||(v=m.length>1&&typeof m[m.length-1]=="object"?m.pop():{}),n.assertOptions(v,["separator"]),m=[].concat(m);const b=n.default(v.separator,"."),u=[];for(const h of m)_(typeof h=="string",f,"peers must be strings"),u.push(c.ref(h,{separator:b,ancestor:0,prefix:!1}));a!==null&&(a=c.ref(a,{separator:b,ancestor:0,prefix:!1}));const p=o.clone();return p.$_terms.dependencies=p.$_terms.dependencies||[],p.$_terms.dependencies.push(new i.Dependency(f,a,u,m)),p},i.dependencies={and(o,f,a,m,v){const b=[],u=[],p=f.peers.length;for(const h of f.peers)h.resolve(a,m,v,null,{shadow:!1})===void 0?b.push(h.key):u.push(h.key);if(b.length!==p&&u.length!==p)return{code:"object.and",context:{present:u,presentWithLabels:i.keysToLabels(o,u),missing:b,missingWithLabels:i.keysToLabels(o,b)}}},nand(o,f,a,m,v){const b=[];for(const h of f.peers)h.resolve(a,m,v,null,{shadow:!1})!==void 0&&b.push(h.key);if(b.length!==f.peers.length)return;const u=f.paths[0],p=f.paths.slice(1);return{code:"object.nand",context:{main:u,mainWithLabel:i.keysToLabels(o,u),peers:p,peersWithLabels:i.keysToLabels(o,p)}}},or(o,f,a,m,v){for(const b of f.peers)if(b.resolve(a,m,v,null,{shadow:!1})!==void 0)return;return{code:"object.missing",context:{peers:f.paths,peersWithLabels:i.keysToLabels(o,f.paths)}}},oxor(o,f,a,m,v){const b=[];for(const p of f.peers)p.resolve(a,m,v,null,{shadow:!1})!==void 0&&b.push(p.key);if(!b.length||b.length===1)return;const u={peers:f.paths,peersWithLabels:i.keysToLabels(o,f.paths)};return u.present=b,u.presentWithLabels=i.keysToLabels(o,b),{code:"object.oxor",context:u}},with(o,f,a,m,v){for(const b of f.peers)if(b.resolve(a,m,v,null,{shadow:!1})===void 0)return{code:"object.with",context:{main:f.key.key,mainWithLabel:i.keysToLabels(o,f.key.key),peer:b.key,peerWithLabel:i.keysToLabels(o,b.key)}}},without(o,f,a,m,v){for(const b of f.peers)if(b.resolve(a,m,v,null,{shadow:!1})!==void 0)return{code:"object.without",context:{main:f.key.key,mainWithLabel:i.keysToLabels(o,f.key.key),peer:b.key,peerWithLabel:i.keysToLabels(o,b.key)}}},xor(o,f,a,m,v){const b=[];for(const p of f.peers)p.resolve(a,m,v,null,{shadow:!1})!==void 0&&b.push(p.key);if(b.length===1)return;const u={peers:f.paths,peersWithLabels:i.keysToLabels(o,f.paths)};return b.length===0?{code:"object.missing",context:u}:(u.present=b,u.presentWithLabels=i.keysToLabels(o,b),{code:"object.xor",context:u})}},i.keysToLabels=function(o,f){return Array.isArray(f)?f.map(a=>o.$_mapLabels(a)):o.$_mapLabels(f)},i.rename=function(o,f,a,m,v){const b={};for(const u of o.$_terms.renames){const p=[],h=typeof u.from!="string";if(h)for(const $ in f){if(f[$]===void 0&&u.options.ignoreUndefined||$===u.to)continue;const A=u.from.exec($);A&&p.push({from:$,to:u.to,match:A})}else!Object.prototype.hasOwnProperty.call(f,u.from)||f[u.from]===void 0&&u.options.ignoreUndefined||p.push(u);for(const $ of p){const A=$.from;let R=$.to;if(R instanceof s&&(R=R.render(f,a,m,$.match)),A!==R){if(!u.options.multiple&&b[R]&&(v.push(o.$_createError("object.rename.multiple",f,{from:A,to:R,pattern:h},a,m)),m.abortEarly)||Object.prototype.hasOwnProperty.call(f,R)&&!u.options.override&&!b[R]&&(v.push(o.$_createError("object.rename.override",f,{from:A,to:R,pattern:h},a,m)),m.abortEarly))return!1;f[A]===void 0?delete f[R]:f[R]=f[A],b[R]=!0,u.options.alias||delete f[A]}}}return!0},i.unknown=function(o,f,a,m,v,b){if(o.$_terms.patterns){let u=!1;const p=o.$_terms.patterns.map($=>{if($.matches)return u=!0,[]}),h=[f,...v.ancestors];for(const $ of a){const A=f[$],R=[...v.path,$];for(let F=0;F<o.$_terms.patterns.length;++F){const L=o.$_terms.patterns[F];if(L.regex){const K=L.regex.test($);if(v.mainstay.tracer.debug(v,"rule","pattern.".concat(F),K?"pass":"error"),!K)continue}else if(!L.schema.$_match($,v.nest(L.schema,"pattern.".concat(F)),b))continue;a.delete($);const V=v.localize(R,h,{schema:L.rule,key:$}),W=L.rule.$_validate(A,V,b);if(W.errors){if(b.abortEarly)return{value:f,errors:W.errors};m.push(...W.errors)}if(L.matches&&p[F].push($),f[$]=W.value,!L.fallthrough)break}}if(u)for(let $=0;$<p.length;++$){const A=p[$];if(!A)continue;const R=o.$_terms.patterns[$].matches,F=v.localize(v.path,h,R),L=R.$_validate(A,F,b);if(L.errors){const V=r.details(L.errors,{override:!1});V.matches=A;const W=o.$_createError("object.pattern.match",f,V,v,b);if(b.abortEarly)return{value:f,errors:W};m.push(W)}}}if(a.size&&(o.$_terms.keys||o.$_terms.patterns)){if(b.stripUnknown&&!o._flags.unknown||b.skipFunctions){const u=!(!b.stripUnknown||b.stripUnknown!==!0&&!b.stripUnknown.objects);for(const p of a)u?(delete f[p],a.delete(p)):typeof f[p]=="function"&&a.delete(p)}if(!n.default(o._flags.unknown,b.allowUnknown))for(const u of a){const p=v.localize([...v.path,u],[]),h=o.$_createError("object.unknown",f[u],{child:u},p,b,{flags:!1});if(b.abortEarly)return{value:f,errors:h};m.push(h)}}},i.Dependency=class{constructor(o,f,a,m){this.rel=o,this.key=f,this.peers=a,this.paths=m}describe(){const o={rel:this.rel,peers:this.paths};return this.key!==null&&(o.key=this.key.key),this.peers[0].separator!=="."&&(o.options={separator:this.peers[0].separator}),o}},i.Keys=class extends Array{concat(o){const f=this.slice(),a=new Map;for(let m=0;m<f.length;++m)a.set(f[m].key,m);for(const m of o){const v=m.key,b=a.get(v);b!==void 0?f[b]={key:v,schema:f[b].schema.concat(m.schema)}:f.push(m)}return f}}},8785:(O,x,g)=>{const l=g(375),_=g(8068),y=g(8160),d=g(3292),e=g(6354),n={};O.exports=_.extend({type:"link",properties:{schemaChain:!0},terms:{link:{init:null,manifest:"single",register:!1}},args:(c,r)=>c.ref(r),validate(c,{schema:r,state:t,prefs:s}){l(r.$_terms.link,"Uninitialized link schema");const i=n.generate(r,c,t,s),o=r.$_terms.link[0].ref;return i.$_validate(c,t.nest(i,"link:".concat(o.display,":").concat(i.type)),s)},generate:(c,r,t,s)=>n.generate(c,r,t,s),rules:{ref:{method(c){l(!this.$_terms.link,"Cannot reinitialize schema"),c=d.ref(c),l(c.type==="value"||c.type==="local","Invalid reference type:",c.type),l(c.type==="local"||c.ancestor==="root"||c.ancestor>0,"Link cannot reference itself");const r=this.clone();return r.$_terms.link=[{ref:c}],r}},relative:{method(c=!0){return this.$_setFlag("relative",c)}}},overrides:{concat(c){l(this.$_terms.link,"Uninitialized link schema"),l(y.isSchema(c),"Invalid schema object"),l(c.type!=="link","Cannot merge type link with another link");const r=this.clone();return r.$_terms.whens||(r.$_terms.whens=[]),r.$_terms.whens.push({concat:c}),r.$_mutateRebuild()}},manifest:{build:(c,r)=>(l(r.link,"Invalid link description missing link"),c.ref(r.link))}}),n.generate=function(c,r,t,s){let i=t.mainstay.links.get(c);if(i)return i._generate(r,t,s).schema;const o=c.$_terms.link[0].ref,{perspective:f,path:a}=n.perspective(o,t);n.assert(f,"which is outside of schema boundaries",o,c,t,s);try{i=a.length?f.$_reach(a):f}catch{n.assert(!1,"to non-existing schema",o,c,t,s)}return n.assert(i.type!=="link","which is another link",o,c,t,s),c._flags.relative||t.mainstay.links.set(c,i),i._generate(r,t,s).schema},n.perspective=function(c,r){if(c.type==="local"){for(const{schema:t,key:s}of r.schemas){if((t._flags.id||s)===c.path[0])return{perspective:t,path:c.path.slice(1)};if(t.$_terms.shared){for(const i of t.$_terms.shared)if(i._flags.id===c.path[0])return{perspective:i,path:c.path.slice(1)}}}return{perspective:null,path:null}}return c.ancestor==="root"?{perspective:r.schemas[r.schemas.length-1].schema,path:c.path}:{perspective:r.schemas[c.ancestor]&&r.schemas[c.ancestor].schema,path:c.path}},n.assert=function(c,r,t,s,i,o){c||l(!1,'"'.concat(e.label(s._flags,i,o),'" contains link reference "').concat(t.display,'" ').concat(r))}},3832:(O,x,g)=>{const l=g(375),_=g(8068),y=g(8160),d={numberRx:/^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,precisionRx:/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/};O.exports=_.extend({type:"number",flags:{unsafe:{default:!1}},coerce:{from:"string",method(e,{schema:n,error:c}){const r=e.match(d.numberRx);if(!r)return;e=e.trim();const t={value:parseFloat(e)};if(t.value===0&&(t.value=0),!n._flags.unsafe)if(e.match(/e/i)){if(d.normalizeExponent("".concat(t.value/Math.pow(10,r[1]),"e").concat(r[1]))!==d.normalizeExponent(e))return t.errors=c("number.unsafe"),t}else{const s=t.value.toString();if(s.match(/e/i))return t;if(s!==d.normalizeDecimal(e))return t.errors=c("number.unsafe"),t}return t}},validate(e,{schema:n,error:c,prefs:r}){if(e===1/0||e===-1/0)return{value:e,errors:c("number.infinity")};if(!y.isNumber(e))return{value:e,errors:c("number.base")};const t={value:e};if(r.convert){const s=n.$_getRule("precision");if(s){const i=Math.pow(10,s.args.limit);t.value=Math.round(t.value*i)/i}}return t.value===0&&(t.value=0),!n._flags.unsafe&&(e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER)&&(t.errors=c("number.unsafe")),t},rules:{compare:{method:!1,validate:(e,n,{limit:c},{name:r,operator:t,args:s})=>y.compare(e,c,t)?e:n.error("number."+r,{limit:s.limit,value:e}),args:[{name:"limit",ref:!0,assert:y.isNumber,message:"must be a number"}]},greater:{method(e){return this.$_addRule({name:"greater",method:"compare",args:{limit:e},operator:">"})}},integer:{method(){return this.$_addRule("integer")},validate:(e,n)=>Math.trunc(e)-e==0?e:n.error("number.integer")},less:{method(e){return this.$_addRule({name:"less",method:"compare",args:{limit:e},operator:"<"})}},max:{method(e){return this.$_addRule({name:"max",method:"compare",args:{limit:e},operator:"<="})}},min:{method(e){return this.$_addRule({name:"min",method:"compare",args:{limit:e},operator:">="})}},multiple:{method(e){return this.$_addRule({name:"multiple",args:{base:e}})},validate:(e,n,{base:c},r)=>e%c==0?e:n.error("number.multiple",{multiple:r.args.base,value:e}),args:[{name:"base",ref:!0,assert:e=>typeof e=="number"&&isFinite(e)&&e>0,message:"must be a positive number"}],multi:!0},negative:{method(){return this.sign("negative")}},port:{method(){return this.$_addRule("port")},validate:(e,n)=>Number.isSafeInteger(e)&&e>=0&&e<=65535?e:n.error("number.port")},positive:{method(){return this.sign("positive")}},precision:{method(e){return l(Number.isSafeInteger(e),"limit must be an integer"),this.$_addRule({name:"precision",args:{limit:e}})},validate(e,n,{limit:c}){const r=e.toString().match(d.precisionRx);return Math.max((r[1]?r[1].length:0)-(r[2]?parseInt(r[2],10):0),0)<=c?e:n.error("number.precision",{limit:c,value:e})},convert:!0},sign:{method(e){return l(["negative","positive"].includes(e),"Invalid sign",e),this.$_addRule({name:"sign",args:{sign:e}})},validate:(e,n,{sign:c})=>c==="negative"&&e<0||c==="positive"&&e>0?e:n.error("number.".concat(c))},unsafe:{method(e=!0){return l(typeof e=="boolean","enabled must be a boolean"),this.$_setFlag("unsafe",e)}}},cast:{string:{from:e=>typeof e=="number",to:(e,n)=>e.toString()}},messages:{"number.base":"{{#label}} must be a number","number.greater":"{{#label}} must be greater than {{#limit}}","number.infinity":"{{#label}} cannot be infinity","number.integer":"{{#label}} must be an integer","number.less":"{{#label}} must be less than {{#limit}}","number.max":"{{#label}} must be less than or equal to {{#limit}}","number.min":"{{#label}} must be greater than or equal to {{#limit}}","number.multiple":"{{#label}} must be a multiple of {{#multiple}}","number.negative":"{{#label}} must be a negative number","number.port":"{{#label}} must be a valid port","number.positive":"{{#label}} must be a positive number","number.precision":"{{#label}} must have no more than {{#limit}} decimal places","number.unsafe":"{{#label}} must be a safe number"}}),d.normalizeExponent=function(e){return e.replace(/E/,"e").replace(/\.(\d*[1-9])?0+e/,".$1e").replace(/\.e/,"e").replace(/e\+/,"e").replace(/^\+/,"").replace(/^(-?)0+([1-9])/,"$1$2")},d.normalizeDecimal=function(e){return(e=e.replace(/^\+/,"").replace(/\.0*$/,"").replace(/^(-?)\.([^\.]*)$/,"$10.$2").replace(/^(-?)0+([0-9])/,"$1$2")).includes(".")&&e.endsWith("0")&&(e=e.replace(/0+$/,"")),e==="-0"?"0":e}},8966:(O,x,g)=>{const l=g(7824);O.exports=l.extend({type:"object",cast:{map:{from:_=>_&&typeof _=="object",to:(_,y)=>new Map(Object.entries(_))}}})},7417:(O,x,g)=>{function l(a,m){var v=Object.keys(a);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(a);m&&(b=b.filter(function(u){return Object.getOwnPropertyDescriptor(a,u).enumerable})),v.push.apply(v,b)}return v}function _(a){for(var m=1;m<arguments.length;m++){var v=arguments[m]!=null?arguments[m]:{};m%2?l(Object(v),!0).forEach(function(b){y(a,b,v[b])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(v)):l(Object(v)).forEach(function(b){Object.defineProperty(a,b,Object.getOwnPropertyDescriptor(v,b))})}return a}function y(a,m,v){return m in a?Object.defineProperty(a,m,{value:v,enumerable:!0,configurable:!0,writable:!0}):a[m]=v,a}const d=g(375),e=g(5380),n=g(1745),c=g(9959),r=g(6064),t=g(9926),s=g(5752),i=g(8068),o=g(8160),f={tlds:t instanceof Set&&{tlds:{allow:t,deny:null}},base64Regex:{true:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/},false:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/}},dataUriRegex:/^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,hexRegex:/^[a-f0-9]+$/i,ipRegex:c.regex().regex,isoDurationRegex:/^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,guidBrackets:{"{":"}","[":"]","(":")","":""},guidVersions:{uuidv1:"1",uuidv2:"2",uuidv3:"3",uuidv4:"4",uuidv5:"5"},guidSeparators:new Set([void 0,!0,!1,"-",":"]),normalizationForms:["NFC","NFD","NFKC","NFKD"]};O.exports=i.extend({type:"string",flags:{insensitive:{default:!1},truncate:{default:!1}},terms:{replacements:{init:null}},coerce:{from:"string",method(a,{schema:m,state:v,prefs:b}){const u=m.$_getRule("normalize");u&&(a=a.normalize(u.args.form));const p=m.$_getRule("case");p&&(a=p.args.direction==="upper"?a.toLocaleUpperCase():a.toLocaleLowerCase());const h=m.$_getRule("trim");if(h&&h.args.enabled&&(a=a.trim()),m.$_terms.replacements)for(const A of m.$_terms.replacements)a=a.replace(A.pattern,A.replacement);const $=m.$_getRule("hex");if($&&$.args.options.byteAligned&&a.length%2!=0&&(a="0".concat(a)),m.$_getRule("isoDate")){const A=f.isoDate(a);A&&(a=A)}if(m._flags.truncate){const A=m.$_getRule("max");if(A){let R=A.args.limit;if(o.isResolvable(R)&&(R=R.resolve(a,v,b),!o.limit(R)))return{value:a,errors:m.$_createError("any.ref",R,{ref:A.args.limit,arg:"limit",reason:"must be a positive integer"},v,b)};a=a.slice(0,R)}}return{value:a}}},validate:(a,{error:m})=>typeof a!="string"?{value:a,errors:m("string.base")}:a===""?{value:a,errors:m("string.empty")}:void 0,rules:{alphanum:{method(){return this.$_addRule("alphanum")},validate:(a,m)=>/^[a-zA-Z0-9]+$/.test(a)?a:m.error("string.alphanum")},base64:{method(a={}){return o.assertOptions(a,["paddingRequired","urlSafe"]),a=_({urlSafe:!1,paddingRequired:!0},a),d(typeof a.paddingRequired=="boolean","paddingRequired must be boolean"),d(typeof a.urlSafe=="boolean","urlSafe must be boolean"),this.$_addRule({name:"base64",args:{options:a}})},validate:(a,m,{options:v})=>f.base64Regex[v.paddingRequired][v.urlSafe].test(a)?a:m.error("string.base64")},case:{method(a){return d(["lower","upper"].includes(a),"Invalid case:",a),this.$_addRule({name:"case",args:{direction:a}})},validate:(a,m,{direction:v})=>v==="lower"&&a===a.toLocaleLowerCase()||v==="upper"&&a===a.toLocaleUpperCase()?a:m.error("string.".concat(v,"case")),convert:!0},creditCard:{method(){return this.$_addRule("creditCard")},validate(a,m){let v=a.length,b=0,u=1;for(;v--;){const p=a.charAt(v)*u;b+=p-9*(p>9),u^=3}return b>0&&b%10==0?a:m.error("string.creditCard")}},dataUri:{method(a={}){return o.assertOptions(a,["paddingRequired"]),a=_({paddingRequired:!0},a),d(typeof a.paddingRequired=="boolean","paddingRequired must be boolean"),this.$_addRule({name:"dataUri",args:{options:a}})},validate(a,m,{options:v}){const b=a.match(f.dataUriRegex);return b&&(!b[2]||b[2]!=="base64"||f.base64Regex[v.paddingRequired].false.test(b[3]))?a:m.error("string.dataUri")}},domain:{method(a){a&&o.assertOptions(a,["allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const m=f.addressOptions(a);return this.$_addRule({name:"domain",args:{options:a},address:m})},validate:(a,m,v,{address:b})=>e.isValid(a,b)?a:m.error("string.domain")},email:{method(a={}){o.assertOptions(a,["allowUnicode","ignoreLength","maxDomainSegments","minDomainSegments","multiple","separator","tlds"]),d(a.multiple===void 0||typeof a.multiple=="boolean","multiple option must be an boolean");const m=f.addressOptions(a),v=new RegExp("\\s*[".concat(a.separator?r(a.separator):",","]\\s*"));return this.$_addRule({name:"email",args:{options:a},regex:v,address:m})},validate(a,m,{options:v},{regex:b,address:u}){const p=v.multiple?a.split(b):[a],h=[];for(const $ of p)n.isValid($,u)||h.push($);return h.length?m.error("string.email",{value:a,invalids:h}):a}},guid:{alias:"uuid",method(a={}){o.assertOptions(a,["version","separator"]);let m="";if(a.version){const u=[].concat(a.version);d(u.length>=1,"version must have at least 1 valid version specified");const p=new Set;for(let h=0;h<u.length;++h){const $=u[h];d(typeof $=="string","version at position "+h+" must be a string");const A=f.guidVersions[$.toLowerCase()];d(A,"version at position "+h+" must be one of "+Object.keys(f.guidVersions).join(", ")),d(!p.has(A),"version at position "+h+" must not be a duplicate"),m+=A,p.add(A)}}d(f.guidSeparators.has(a.separator),'separator must be one of true, false, "-", or ":"');const v=a.separator===void 0?"[:-]?":a.separator===!0?"[:-]":a.separator===!1?"[]?":"\\".concat(a.separator),b=new RegExp("^([\\[{\\(]?)[0-9A-F]{8}(".concat(v,")[0-9A-F]{4}\\2?[").concat(m||"0-9A-F","][0-9A-F]{3}\\2?[").concat(m?"89AB":"0-9A-F","][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$"),"i");return this.$_addRule({name:"guid",args:{options:a},regex:b})},validate(a,m,v,{regex:b}){const u=b.exec(a);return u?f.guidBrackets[u[1]]!==u[u.length-1]?m.error("string.guid"):a:m.error("string.guid")}},hex:{method(a={}){return o.assertOptions(a,["byteAligned"]),a=_({byteAligned:!1},a),d(typeof a.byteAligned=="boolean","byteAligned must be boolean"),this.$_addRule({name:"hex",args:{options:a}})},validate:(a,m,{options:v})=>f.hexRegex.test(a)?v.byteAligned&&a.length%2!=0?m.error("string.hexAlign"):a:m.error("string.hex")},hostname:{method(){return this.$_addRule("hostname")},validate:(a,m)=>e.isValid(a,{minDomainSegments:1})||f.ipRegex.test(a)?a:m.error("string.hostname")},insensitive:{method(){return this.$_setFlag("insensitive",!0)}},ip:{method(a={}){o.assertOptions(a,["cidr","version"]);const{cidr:m,versions:v,regex:b}=c.regex(a),u=a.version?v:void 0;return this.$_addRule({name:"ip",args:{options:{cidr:m,version:u}},regex:b})},validate:(a,m,{options:v},{regex:b})=>b.test(a)?a:v.version?m.error("string.ipVersion",{value:a,cidr:v.cidr,version:v.version}):m.error("string.ip",{value:a,cidr:v.cidr})},isoDate:{method(){return this.$_addRule("isoDate")},validate:(a,{error:m})=>f.isoDate(a)?a:m("string.isoDate")},isoDuration:{method(){return this.$_addRule("isoDuration")},validate:(a,m)=>f.isoDurationRegex.test(a)?a:m.error("string.isoDuration")},length:{method(a,m){return f.length(this,"length",a,"=",m)},validate(a,m,{limit:v,encoding:b},{name:u,operator:p,args:h}){const $=!b&&a.length;return o.compare($,v,p)?a:m.error("string."+u,{limit:h.limit,value:a,encoding:b})},args:[{name:"limit",ref:!0,assert:o.limit,message:"must be a positive integer"},"encoding"]},lowercase:{method(){return this.case("lower")}},max:{method(a,m){return f.length(this,"max",a,"<=",m)},args:["limit","encoding"]},min:{method(a,m){return f.length(this,"min",a,">=",m)},args:["limit","encoding"]},normalize:{method(a="NFC"){return d(f.normalizationForms.includes(a),"normalization form must be one of "+f.normalizationForms.join(", ")),this.$_addRule({name:"normalize",args:{form:a}})},validate:(a,{error:m},{form:v})=>a===a.normalize(v)?a:m("string.normalize",{value:a,form:v}),convert:!0},pattern:{alias:"regex",method(a,m={}){d(a instanceof RegExp,"regex must be a RegExp"),d(!a.flags.includes("g")&&!a.flags.includes("y"),"regex should not use global or sticky mode"),typeof m=="string"&&(m={name:m}),o.assertOptions(m,["invert","name"]);const v=["string.pattern",m.invert?".invert":"",m.name?".name":".base"].join("");return this.$_addRule({name:"pattern",args:{regex:a,options:m},errorCode:v})},validate:(a,m,{regex:v,options:b},{errorCode:u})=>v.test(a)^b.invert?a:m.error(u,{name:b.name,regex:v,value:a}),args:["regex","options"],multi:!0},replace:{method(a,m){typeof a=="string"&&(a=new RegExp(r(a),"g")),d(a instanceof RegExp,"pattern must be a RegExp"),d(typeof m=="string","replacement must be a String");const v=this.clone();return v.$_terms.replacements||(v.$_terms.replacements=[]),v.$_terms.replacements.push({pattern:a,replacement:m}),v}},token:{method(){return this.$_addRule("token")},validate:(a,m)=>/^\w+$/.test(a)?a:m.error("string.token")},trim:{method(a=!0){return d(typeof a=="boolean","enabled must be a boolean"),this.$_addRule({name:"trim",args:{enabled:a}})},validate:(a,m,{enabled:v})=>v&&a!==a.trim()?m.error("string.trim"):a,convert:!0},truncate:{method(a=!0){return d(typeof a=="boolean","enabled must be a boolean"),this.$_setFlag("truncate",a)}},uppercase:{method(){return this.case("upper")}},uri:{method(a={}){o.assertOptions(a,["allowRelative","allowQuerySquareBrackets","domain","relativeOnly","scheme"]),a.domain&&o.assertOptions(a.domain,["allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const{regex:m,scheme:v}=s.regex(a),b=a.domain?f.addressOptions(a.domain):null;return this.$_addRule({name:"uri",args:{options:a},regex:m,domain:b,scheme:v})},validate(a,m,{options:v},{regex:b,domain:u,scheme:p}){if(["http:/","https:/"].includes(a))return m.error("string.uri");const h=b.exec(a);if(h){const $=h[1]||h[2];return!u||v.allowRelative&&!$||e.isValid($,u)?a:m.error("string.domain",{value:$})}return v.relativeOnly?m.error("string.uriRelativeOnly"):v.scheme?m.error("string.uriCustomScheme",{scheme:p,value:a}):m.error("string.uri")}}},manifest:{build(a,m){if(m.replacements)for(const{pattern:v,replacement:b}of m.replacements)a=a.replace(v,b);return a}},messages:{"string.alphanum":"{{#label}} must only contain alpha-numeric characters","string.base":"{{#label}} must be a string","string.base64":"{{#label}} must be a valid base64 string","string.creditCard":"{{#label}} must be a credit card","string.dataUri":"{{#label}} must be a valid dataUri string","string.domain":"{{#label}} must contain a valid domain name","string.email":"{{#label}} must be a valid email","string.empty":"{{#label}} is not allowed to be empty","string.guid":"{{#label}} must be a valid GUID","string.hex":"{{#label}} must only contain hexadecimal characters","string.hexAlign":"{{#label}} hex decoded representation must be byte aligned","string.hostname":"{{#label}} must be a valid hostname","string.ip":"{{#label}} must be a valid ip address with a {{#cidr}} CIDR","string.ipVersion":"{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR","string.isoDate":"{{#label}} must be in iso format","string.isoDuration":"{{#label}} must be a valid ISO 8601 duration","string.length":"{{#label}} length must be {{#limit}} characters long","string.lowercase":"{{#label}} must only contain lowercase characters","string.max":"{{#label}} length must be less than or equal to {{#limit}} characters long","string.min":"{{#label}} length must be at least {{#limit}} characters long","string.normalize":"{{#label}} must be unicode normalized in the {{#form}} form","string.token":"{{#label}} must only contain alpha-numeric and underscore characters","string.pattern.base":"{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}","string.pattern.name":"{{#label}} with value {:[.]} fails to match the {{#name}} pattern","string.pattern.invert.base":"{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}","string.pattern.invert.name":"{{#label}} with value {:[.]} matches the inverted {{#name}} pattern","string.trim":"{{#label}} must not have leading or trailing whitespace","string.uri":"{{#label}} must be a valid uri","string.uriCustomScheme":"{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern","string.uriRelativeOnly":"{{#label}} must be a valid relative uri","string.uppercase":"{{#label}} must only contain uppercase characters"}}),f.addressOptions=function(a){if(!a||(d(a.minDomainSegments===void 0||Number.isSafeInteger(a.minDomainSegments)&&a.minDomainSegments>0,"minDomainSegments must be a positive integer"),d(a.maxDomainSegments===void 0||Number.isSafeInteger(a.maxDomainSegments)&&a.maxDomainSegments>0,"maxDomainSegments must be a positive integer"),a.tlds===!1))return a;if(a.tlds===!0||a.tlds===void 0)return d(f.tlds,"Built-in TLD list disabled"),Object.assign({},a,f.tlds);d(typeof a.tlds=="object","tlds must be true, false, or an object");const m=a.tlds.deny;if(m)return Array.isArray(m)&&(a=Object.assign({},a,{tlds:{deny:new Set(m)}})),d(a.tlds.deny instanceof Set,"tlds.deny must be an array, Set, or boolean"),d(!a.tlds.allow,"Cannot specify both tlds.allow and tlds.deny lists"),f.validateTlds(a.tlds.deny,"tlds.deny"),a;const v=a.tlds.allow;return v?v===!0?(d(f.tlds,"Built-in TLD list disabled"),Object.assign({},a,f.tlds)):(Array.isArray(v)&&(a=Object.assign({},a,{tlds:{allow:new Set(v)}})),d(a.tlds.allow instanceof Set,"tlds.allow must be an array, Set, or boolean"),f.validateTlds(a.tlds.allow,"tlds.allow"),a):a},f.validateTlds=function(a,m){for(const v of a)d(e.isValid(v,{minDomainSegments:1,maxDomainSegments:1}),"".concat(m," must contain valid top level domain names"))},f.isoDate=function(a){if(!o.isIsoDate(a))return null;/.*T.*[+-]\d\d$/.test(a)&&(a+="00");const m=new Date(a);return isNaN(m.getTime())?null:m.toISOString()},f.length=function(a,m,v,b,u){return d(!u||!1,"Invalid encoding:",u),a.$_addRule({name:m,method:"length",args:{limit:v,encoding:u},operator:b})}},8826:(O,x,g)=>{const l=g(375),_=g(8068),y={};y.Map=class extends Map{slice(){return new y.Map(this)}},O.exports=_.extend({type:"symbol",terms:{map:{init:new y.Map}},coerce:{method(d,{schema:e,error:n}){const c=e.$_terms.map.get(d);return c&&(d=c),e._flags.only&&typeof d!="symbol"?{value:d,errors:n("symbol.map",{map:e.$_terms.map})}:{value:d}}},validate(d,{error:e}){if(typeof d!="symbol")return{value:d,errors:e("symbol.base")}},rules:{map:{method(d){d&&!d[Symbol.iterator]&&typeof d=="object"&&(d=Object.entries(d)),l(d&&d[Symbol.iterator],"Iterable must be an iterable or object");const e=this.clone(),n=[];for(const c of d){l(c&&c[Symbol.iterator],"Entry must be an iterable");const[r,t]=c;l(typeof r!="object"&&typeof r!="function"&&typeof r!="symbol","Key must not be of type object, function, or Symbol"),l(typeof t=="symbol","Value must be a Symbol"),e.$_terms.map.set(r,t),n.push(t)}return e.valid(...n)}}},manifest:{build:(d,e)=>(e.map&&(d=d.map(e.map)),d)},messages:{"symbol.base":"{{#label}} must be a symbol","symbol.map":"{{#label}} must be one of {{#map}}"}})},8863:(O,x,g)=>{const l=g(375),_=g(8571),y=g(738),d=g(9621),e=g(8160),n=g(6354),c=g(493),r={result:Symbol("result")};x.entry=function(t,s,i){let o=e.defaults;i&&(l(i.warnings===void 0,"Cannot override warnings preference in synchronous validation"),l(i.artifacts===void 0,"Cannot override artifacts preference in synchronous validation"),o=e.preferences(e.defaults,i));const f=r.entry(t,s,o);l(!f.mainstay.externals.length,"Schema with external rules must use validateAsync()");const a={value:f.value};return f.error&&(a.error=f.error),f.mainstay.warnings.length&&(a.warning=n.details(f.mainstay.warnings)),f.mainstay.debug&&(a.debug=f.mainstay.debug),f.mainstay.artifacts&&(a.artifacts=f.mainstay.artifacts),a},x.entryAsync=async function(t,s,i){let o=e.defaults;i&&(o=e.preferences(e.defaults,i));const f=r.entry(t,s,o),a=f.mainstay;if(f.error)throw a.debug&&(f.error.debug=a.debug),f.error;if(a.externals.length){let v=f.value;for(const{method:b,path:u,label:p}of a.externals){let h,$,A=v;u.length&&(h=u[u.length-1],$=d(v,u.slice(0,-1)),A=$[h]);try{const R=await b(A,{prefs:i});if(R===void 0||R===A)continue;$?$[h]=R:v=R}catch(R){throw R.message+=" (".concat(p,")"),R}}f.value=v}if(!o.warnings&&!o.debug&&!o.artifacts)return f.value;const m={value:f.value};return a.warnings.length&&(m.warning=n.details(a.warnings)),a.debug&&(m.debug=a.debug),a.artifacts&&(m.artifacts=a.artifacts),m},r.entry=function(t,s,i){const{tracer:o,cleanup:f}=r.tracer(s,i),a={externals:[],warnings:[],tracer:o,debug:i.debug?[]:null,links:s._ids._schemaChain?new Map:null},m=s._ids._schemaChain?[{schema:s}]:null,v=new c([],[],{mainstay:a,schemas:m}),b=x.validate(t,s,v,i);f&&s.$_root.untrace();const u=n.process(b.errors,t,i);return{value:b.value,error:u,mainstay:a}},r.tracer=function(t,s){return t.$_root._tracer?{tracer:t.$_root._tracer._register(t)}:s.debug?(l(t.$_root.trace,"Debug mode not supported"),{tracer:t.$_root.trace()._register(t),cleanup:!0}):{tracer:r.ignore}},x.validate=function(t,s,i,o,f={}){if(s.$_terms.whens&&(s=s._generate(t,i,o).schema),s._preferences&&(o=r.prefs(s,o)),s._cache&&o.cache){const h=s._cache.get(t);if(i.mainstay.tracer.debug(i,"validate","cached",!!h),h)return h}const a=(h,$,A)=>s.$_createError(h,t,$,A||i,o),m={original:t,prefs:o,schema:s,state:i,error:a,errorsArray:r.errorsArray,warn:(h,$,A)=>i.mainstay.warnings.push(a(h,$,A)),message:(h,$)=>s.$_createError("custom",t,$,i,o,{messages:h})};i.mainstay.tracer.entry(s,i);const v=s._definition;if(v.prepare&&t!==void 0&&o.convert){const h=v.prepare(t,m);if(h){if(i.mainstay.tracer.value(i,"prepare",t,h.value),h.errors)return r.finalize(h.value,[].concat(h.errors),m);t=h.value}}if(v.coerce&&t!==void 0&&o.convert&&(!v.coerce.from||v.coerce.from.includes(typeof t))){const h=v.coerce.method(t,m);if(h){if(i.mainstay.tracer.value(i,"coerced",t,h.value),h.errors)return r.finalize(h.value,[].concat(h.errors),m);t=h.value}}const b=s._flags.empty;b&&b.$_match(r.trim(t,s),i.nest(b),e.defaults)&&(i.mainstay.tracer.value(i,"empty",t,void 0),t=void 0);const u=f.presence||s._flags.presence||(s._flags._endedSwitch?null:o.presence);if(t===void 0){if(u==="forbidden")return r.finalize(t,null,m);if(u==="required")return r.finalize(t,[s.$_createError("any.required",t,null,i,o)],m);if(u==="optional"){if(s._flags.default!==e.symbols.deepDefault)return r.finalize(t,null,m);i.mainstay.tracer.value(i,"default",t,{}),t={}}}else if(u==="forbidden")return r.finalize(t,[s.$_createError("any.unknown",t,null,i,o)],m);const p=[];if(s._valids){const h=s._valids.get(t,i,o,s._flags.insensitive);if(h)return o.convert&&(i.mainstay.tracer.value(i,"valids",t,h.value),t=h.value),i.mainstay.tracer.filter(s,i,"valid",h),r.finalize(t,null,m);if(s._flags.only){const $=s.$_createError("any.only",t,{valids:s._valids.values({display:!0})},i,o);if(o.abortEarly)return r.finalize(t,[$],m);p.push($)}}if(s._invalids){const h=s._invalids.get(t,i,o,s._flags.insensitive);if(h){i.mainstay.tracer.filter(s,i,"invalid",h);const $=s.$_createError("any.invalid",t,{invalids:s._invalids.values({display:!0})},i,o);if(o.abortEarly)return r.finalize(t,[$],m);p.push($)}}if(v.validate){const h=v.validate(t,m);if(h&&(i.mainstay.tracer.value(i,"base",t,h.value),t=h.value,h.errors)){if(!Array.isArray(h.errors))return p.push(h.errors),r.finalize(t,p,m);if(h.errors.length)return p.push(...h.errors),r.finalize(t,p,m)}}return s._rules.length?r.rules(t,p,m):r.finalize(t,p,m)},r.rules=function(t,s,i){const{schema:o,state:f,prefs:a}=i;for(const m of o._rules){const v=o._definition.rules[m.method];if(v.convert&&a.convert){f.mainstay.tracer.log(o,f,"rule",m.name,"full");continue}let b,u=m.args;if(m._resolve.length){u=Object.assign({},u);for(const h of m._resolve){const $=v.argsByName.get(h),A=u[h].resolve(t,f,a),R=$.normalize?$.normalize(A):A,F=e.validateArg(R,null,$);if(F){b=o.$_createError("any.ref",A,{arg:h,ref:u[h],reason:F},f,a);break}u[h]=R}}b=b||v.validate(t,i,u,m);const p=r.rule(b,m);if(p.errors){if(f.mainstay.tracer.log(o,f,"rule",m.name,"error"),m.warn){f.mainstay.warnings.push(...p.errors);continue}if(a.abortEarly)return r.finalize(t,p.errors,i);s.push(...p.errors)}else f.mainstay.tracer.log(o,f,"rule",m.name,"pass"),f.mainstay.tracer.value(f,"rule",t,p.value,m.name),t=p.value}return r.finalize(t,s,i)},r.rule=function(t,s){return t instanceof n.Report?(r.error(t,s),{errors:[t],value:null}):Array.isArray(t)&&t[e.symbols.errors]?(t.forEach(i=>r.error(i,s)),{errors:t,value:null}):{errors:null,value:t}},r.error=function(t,s){return s.message&&t._setTemplate(s.message),t},r.finalize=function(t,s,i){s=s||[];const{schema:o,state:f,prefs:a}=i;if(s.length){const v=r.default("failover",void 0,s,i);v!==void 0&&(f.mainstay.tracer.value(f,"failover",t,v),t=v,s=[])}if(s.length&&o._flags.error)if(typeof o._flags.error=="function"){s=o._flags.error(s),Array.isArray(s)||(s=[s]);for(const v of s)l(v instanceof Error||v instanceof n.Report,"error() must return an Error object")}else s=[o._flags.error];if(t===void 0){const v=r.default("default",t,s,i);f.mainstay.tracer.value(f,"default",t,v),t=v}if(o._flags.cast&&t!==void 0){const v=o._definition.cast[o._flags.cast];if(v.from(t)){const b=v.to(t,i);f.mainstay.tracer.value(f,"cast",t,b,o._flags.cast),t=b}}if(o.$_terms.externals&&a.externals&&a._externals!==!1)for(const{method:v}of o.$_terms.externals)f.mainstay.externals.push({method:v,path:f.path,label:n.label(o._flags,f,a)});const m={value:t,errors:s.length?s:null};return o._flags.result&&(m.value=o._flags.result==="strip"?void 0:i.original,f.mainstay.tracer.value(f,o._flags.result,t,m.value),f.shadow(t,o._flags.result)),o._cache&&a.cache!==!1&&!o._refs.length&&o._cache.set(i.original,m),t===void 0||m.errors||o._flags.artifact===void 0||(f.mainstay.artifacts=f.mainstay.artifacts||new Map,f.mainstay.artifacts.has(o._flags.artifact)||f.mainstay.artifacts.set(o._flags.artifact,[]),f.mainstay.artifacts.get(o._flags.artifact).push(f.path)),m},r.prefs=function(t,s){const i=s===e.defaults;return i&&t._preferences[e.symbols.prefs]?t._preferences[e.symbols.prefs]:(s=e.preferences(s,t._preferences),i&&(t._preferences[e.symbols.prefs]=s),s)},r.default=function(t,s,i,o){const{schema:f,state:a,prefs:m}=o,v=f._flags[t];if(m.noDefaults||v===void 0)return s;if(a.mainstay.tracer.log(f,a,"rule",t,"full"),!v)return v;if(typeof v=="function"){const b=v.length?[_(a.ancestors[0]),o]:[];try{return v(...b)}catch(u){return void i.push(f.$_createError("any.".concat(t),null,{error:u},a,m))}}return typeof v!="object"?v:v[e.symbols.literal]?v.literal:e.isResolvable(v)?v.resolve(s,a,m):_(v)},r.trim=function(t,s){if(typeof t!="string")return t;const i=s.$_getRule("trim");return i&&i.args.enabled?t.trim():t},r.ignore={active:!1,debug:y,entry:y,filter:y,log:y,resolve:y,value:y},r.errorsArray=function(){const t=[];return t[e.symbols.errors]=!0,t}},2036:(O,x,g)=>{const l=g(375),_=g(9474),y=g(8160),d={};O.exports=d.Values=class{constructor(e,n){this._values=new Set(e),this._refs=new Set(n),this._lowercase=d.lowercases(e),this._override=!1}get length(){return this._values.size+this._refs.size}add(e,n){y.isResolvable(e)?this._refs.has(e)||(this._refs.add(e),n&&n.register(e)):this.has(e,null,null,!1)||(this._values.add(e),typeof e=="string"&&this._lowercase.set(e.toLowerCase(),e))}static merge(e,n,c){if(e=e||new d.Values,n){if(n._override)return n.clone();for(const r of[...n._values,...n._refs])e.add(r)}if(c)for(const r of[...c._values,...c._refs])e.remove(r);return e.length?e:null}remove(e){y.isResolvable(e)?this._refs.delete(e):(this._values.delete(e),typeof e=="string"&&this._lowercase.delete(e.toLowerCase()))}has(e,n,c,r){return!!this.get(e,n,c,r)}get(e,n,c,r){if(!this.length)return!1;if(this._values.has(e))return{value:e};if(typeof e=="string"&&e&&r){const t=this._lowercase.get(e.toLowerCase());if(t)return{value:t}}if(!this._refs.size&&typeof e!="object")return!1;if(typeof e=="object"){for(const t of this._values)if(_(t,e))return{value:t}}if(n)for(const t of this._refs){const s=t.resolve(e,n,c,null,{in:!0});if(s===void 0)continue;const i=t.in&&typeof s=="object"?Array.isArray(s)?s:Object.keys(s):[s];for(const o of i)if(typeof o==typeof e){if(r&&e&&typeof e=="string"){if(o.toLowerCase()===e.toLowerCase())return{value:o,ref:t}}else if(_(o,e))return{value:o,ref:t}}}return!1}override(){this._override=!0}values(e){if(e&&e.display){const n=[];for(const c of[...this._values,...this._refs])c!==void 0&&n.push(c);return n}return Array.from([...this._values,...this._refs])}clone(){const e=new d.Values(this._values,this._refs);return e._override=this._override,e}concat(e){l(!e._override,"Cannot concat override set of values");const n=new d.Values([...this._values,...e._values],[...this._refs,...e._refs]);return n._override=this._override,n}describe(){const e=[];this._override&&e.push({override:!0});for(const n of this._values.values())e.push(n&&typeof n=="object"?{value:n}:n);for(const n of this._refs.values())e.push(n.describe());return e}},d.Values.prototype[y.symbols.values]=!0,d.Values.prototype.slice=d.Values.prototype.clone,d.lowercases=function(e){const n=new Map;if(e)for(const c of e)typeof c=="string"&&n.set(c.toLowerCase(),c);return n}},978:(O,x,g)=>{const l=g(375),_=g(8571),y=g(1687),d=g(9621),e={};O.exports=function(n,c,r={}){if(l(n&&typeof n=="object","Invalid defaults value: must be an object"),l(!c||c===!0||typeof c=="object","Invalid source value: must be true, falsy or an object"),l(typeof r=="object","Invalid options: must be an object"),!c)return null;if(r.shallow)return e.applyToDefaultsWithShallow(n,c,r);const t=_(n);if(c===!0)return t;const s=r.nullOverride!==void 0&&r.nullOverride;return y(t,c,{nullOverride:s,mergeArrays:!1})},e.applyToDefaultsWithShallow=function(n,c,r){const t=r.shallow;l(Array.isArray(t),"Invalid keys");const s=new Map,i=c===!0?null:new Set;for(let a of t){a=Array.isArray(a)?a:a.split(".");const m=d(n,a);m&&typeof m=="object"?s.set(m,i&&d(c,a)||m):i&&i.add(a)}const o=_(n,{},s);if(!i)return o;for(const a of i)e.reachCopy(o,c,a);const f=r.nullOverride!==void 0&&r.nullOverride;return y(o,c,{nullOverride:f,mergeArrays:!1})},e.reachCopy=function(n,c,r){for(const i of r){if(!(i in c))return;const o=c[i];if(typeof o!="object"||o===null)return;c=o}const t=c;let s=n;for(let i=0;i<r.length-1;++i){const o=r[i];typeof s[o]!="object"&&(s[o]={}),s=s[o]}s[r[r.length-1]]=t}},375:(O,x,g)=>{const l=g(7916);O.exports=function(_,...y){if(!_)throw y.length===1&&y[0]instanceof Error?y[0]:new l(y)}},8571:(O,x,g)=>{const l=g(9621),_=g(4277),y=g(7043),d={needsProtoHack:new Set([_.set,_.map,_.weakSet,_.weakMap])};O.exports=d.clone=function(e,n={},c=null){if(typeof e!="object"||e===null)return e;let r=d.clone,t=c;if(n.shallow){if(n.shallow!==!0)return d.cloneWithShallow(e,n);r=f=>f}else if(t){const f=t.get(e);if(f)return f}else t=new Map;const s=_.getInternalProto(e);if(s===_.buffer)return!1;if(s===_.date)return new Date(e.getTime());if(s===_.regex)return new RegExp(e);const i=d.base(e,s,n);if(i===e)return e;if(t&&t.set(e,i),s===_.set)for(const f of e)i.add(r(f,n,t));else if(s===_.map)for(const[f,a]of e)i.set(f,r(a,n,t));const o=y.keys(e,n);for(const f of o){if(f==="__proto__")continue;if(s===_.array&&f==="length"){i.length=e.length;continue}const a=Object.getOwnPropertyDescriptor(e,f);a?a.get||a.set?Object.defineProperty(i,f,a):a.enumerable?i[f]=r(e[f],n,t):Object.defineProperty(i,f,{enumerable:!1,writable:!0,configurable:!0,value:r(e[f],n,t)}):Object.defineProperty(i,f,{enumerable:!0,writable:!0,configurable:!0,value:r(e[f],n,t)})}return i},d.cloneWithShallow=function(e,n){const c=n.shallow;(n=Object.assign({},n)).shallow=!1;const r=new Map;for(const t of c){const s=l(e,t);typeof s!="object"&&typeof s!="function"||r.set(s,s)}return d.clone(e,n,r)},d.base=function(e,n,c){if(c.prototype===!1)return d.needsProtoHack.has(n)?new n.constructor:n===_.array?[]:{};const r=Object.getPrototypeOf(e);if(r&&r.isImmutable)return e;if(n===_.array){const t=[];return r!==n&&Object.setPrototypeOf(t,r),t}if(d.needsProtoHack.has(n)){const t=new r.constructor;return r!==n&&Object.setPrototypeOf(t,r),t}return Object.create(r)}},9474:(O,x,g)=>{const l=g(4277),_={mismatched:null};O.exports=function(y,d,e){return e=Object.assign({prototype:!0},e),!!_.isDeepEqual(y,d,e,[])},_.isDeepEqual=function(y,d,e,n){if(y===d)return y!==0||1/y==1/d;const c=typeof y;if(c!==typeof d||y===null||d===null)return!1;if(c==="function"){if(!e.deepFunction||y.toString()!==d.toString())return!1}else if(c!=="object")return y!=y&&d!=d;const r=_.getSharedType(y,d,!!e.prototype);switch(r){case l.buffer:return!1;case l.promise:return y===d;case l.regex:return y.toString()===d.toString();case _.mismatched:return!1}for(let t=n.length-1;t>=0;--t)if(n[t].isSame(y,d))return!0;n.push(new _.SeenEntry(y,d));try{return!!_.isDeepEqualObj(r,y,d,e,n)}finally{n.pop()}},_.getSharedType=function(y,d,e){if(e)return Object.getPrototypeOf(y)!==Object.getPrototypeOf(d)?_.mismatched:l.getInternalProto(y);const n=l.getInternalProto(y);return n!==l.getInternalProto(d)?_.mismatched:n},_.valueOf=function(y){const d=y.valueOf;if(d===void 0)return y;try{return d.call(y)}catch(e){return e}},_.hasOwnEnumerableProperty=function(y,d){return Object.prototype.propertyIsEnumerable.call(y,d)},_.isSetSimpleEqual=function(y,d){for(const e of Set.prototype.values.call(y))if(!Set.prototype.has.call(d,e))return!1;return!0},_.isDeepEqualObj=function(y,d,e,n,c){const{isDeepEqual:r,valueOf:t,hasOwnEnumerableProperty:s}=_,{keys:i,getOwnPropertySymbols:o}=Object;if(y===l.array){if(!n.part){if(d.length!==e.length)return!1;for(let b=0;b<d.length;++b)if(!r(d[b],e[b],n,c))return!1;return!0}for(const b of d)for(const u of e)if(r(b,u,n,c))return!0}else if(y===l.set){if(d.size!==e.size)return!1;if(!_.isSetSimpleEqual(d,e)){const b=new Set(Set.prototype.values.call(e));for(const u of Set.prototype.values.call(d)){if(b.delete(u))continue;let p=!1;for(const h of b)if(r(u,h,n,c)){b.delete(h),p=!0;break}if(!p)return!1}}}else if(y===l.map){if(d.size!==e.size)return!1;for(const[b,u]of Map.prototype.entries.call(d))if(u===void 0&&!Map.prototype.has.call(e,b)||!r(u,Map.prototype.get.call(e,b),n,c))return!1}else if(y===l.error&&(d.name!==e.name||d.message!==e.message))return!1;const f=t(d),a=t(e);if((d!==f||e!==a)&&!r(f,a,n,c))return!1;const m=i(d);if(!n.part&&m.length!==i(e).length&&!n.skip)return!1;let v=0;for(const b of m)if(n.skip&&n.skip.includes(b))e[b]===void 0&&++v;else if(!s(e,b)||!r(d[b],e[b],n,c))return!1;if(!n.part&&m.length-v!==i(e).length)return!1;if(n.symbols!==!1){const b=o(d),u=new Set(o(e));for(const p of b){if(!n.skip||!n.skip.includes(p)){if(s(d,p)){if(!s(e,p)||!r(d[p],e[p],n,c))return!1}else if(s(e,p))return!1}u.delete(p)}for(const p of u)if(s(e,p))return!1}return!0},_.SeenEntry=class{constructor(y,d){this.obj=y,this.ref=d}isSame(y,d){return this.obj===y&&this.ref===d}}},7916:(O,x,g)=>{const l=g(8761);O.exports=class extends Error{constructor(_){super(_.filter(y=>y!=="").map(y=>typeof y=="string"?y:y instanceof Error?y.message:l(y)).join(" ")||"Unknown error"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,x.assert)}}},5277:O=>{const x={};O.exports=function(g){if(!g)return"";let l="";for(let _=0;_<g.length;++_){const y=g.charCodeAt(_);x.isSafe(y)?l+=g[_]:l+=x.escapeHtmlChar(y)}return l},x.escapeHtmlChar=function(g){const l=x.namedHtml[g];if(l!==void 0)return l;if(g>=256)return"&#"+g+";";const _=g.toString(16).padStart(2,"0");return"&#x".concat(_,";")},x.isSafe=function(g){return x.safeCharCodes[g]!==void 0},x.namedHtml={38:"&amp;",60:"&lt;",62:"&gt;",34:"&quot;",160:"&nbsp;",162:"&cent;",163:"&pound;",164:"&curren;",169:"&copy;",174:"&reg;"},x.safeCharCodes=function(){const g={};for(let l=32;l<123;++l)(l>=97||l>=65&&l<=90||l>=48&&l<=57||l===32||l===46||l===44||l===45||l===58||l===95)&&(g[l]=null);return g}()},6064:O=>{O.exports=function(x){return x.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,"\\$&")}},738:O=>{O.exports=function(){}},1687:(O,x,g)=>{const l=g(375),_=g(8571),y=g(7043),d={};O.exports=d.merge=function(e,n,c){if(l(e&&typeof e=="object","Invalid target value: must be an object"),l(n==null||typeof n=="object","Invalid source value: must be null, undefined, or an object"),!n)return e;if(c=Object.assign({nullOverride:!0,mergeArrays:!0},c),Array.isArray(n)){l(Array.isArray(e),"Cannot merge array onto an object"),c.mergeArrays||(e.length=0);for(let t=0;t<n.length;++t)e.push(_(n[t],{symbols:c.symbols}));return e}const r=y.keys(n,c);for(let t=0;t<r.length;++t){const s=r[t];if(s==="__proto__"||!Object.prototype.propertyIsEnumerable.call(n,s))continue;const i=n[s];if(i&&typeof i=="object"){if(e[s]===i)continue;!e[s]||typeof e[s]!="object"||Array.isArray(e[s])!==Array.isArray(i)||i instanceof Date||i instanceof RegExp?e[s]=_(i,{symbols:c.symbols}):d.merge(e[s],i,c)}else(i!=null||c.nullOverride)&&(e[s]=i)}return e}},9621:(O,x,g)=>{const l=g(375),_={};O.exports=function(y,d,e){if(d===!1||d==null)return y;typeof(e=e||{})=="string"&&(e={separator:e});const n=Array.isArray(d);l(!n||!e.separator,"Separator option no valid for array-based chain");const c=n?d:d.split(e.separator||".");let r=y;for(let t=0;t<c.length;++t){let s=c[t];const i=e.iterables&&_.iterables(r);if(Array.isArray(r)||i==="set"){const o=Number(s);Number.isInteger(o)&&(s=o<0?r.length+o:o)}if(!r||typeof r=="function"&&e.functions===!1||!i&&r[s]===void 0){l(!e.strict||t+1===c.length,"Missing segment",s,"in reach path ",d),l(typeof r=="object"||e.functions===!0||typeof r!="function","Invalid segment",s,"in reach path ",d),r=e.default;break}r=i?i==="set"?[...r][s]:r.get(s):r[s]}return r},_.iterables=function(y){return y instanceof Set?"set":y instanceof Map?"map":void 0}},8761:O=>{O.exports=function(...x){try{return JSON.stringify.apply(null,x)}catch(g){return"[Cannot display object: "+g.message+"]"}}},4277:(O,x)=>{const g={};x=O.exports={array:Array.prototype,buffer:!1,date:Date.prototype,error:Error.prototype,generic:Object.prototype,map:Map.prototype,promise:Promise.prototype,regex:RegExp.prototype,set:Set.prototype,weakMap:WeakMap.prototype,weakSet:WeakSet.prototype},g.typeMap=new Map([["[object Error]",x.error],["[object Map]",x.map],["[object Promise]",x.promise],["[object Set]",x.set],["[object WeakMap]",x.weakMap],["[object WeakSet]",x.weakSet]]),x.getInternalProto=function(l){if(Array.isArray(l))return x.array;if(l instanceof Date)return x.date;if(l instanceof RegExp)return x.regex;if(l instanceof Error)return x.error;const _=Object.prototype.toString.call(l);return g.typeMap.get(_)||x.generic}},7043:(O,x)=>{x.keys=function(g,l={}){return l.symbols!==!1?Reflect.ownKeys(g):Object.getOwnPropertyNames(g)}},3652:(O,x,g)=>{const l=g(375),_={};x.Sorter=class{constructor(){this._items=[],this.nodes=[]}add(y,d){const e=[].concat((d=d||{}).before||[]),n=[].concat(d.after||[]),c=d.group||"?",r=d.sort||0;l(!e.includes(c),"Item cannot come before itself: ".concat(c)),l(!e.includes("?"),"Item cannot come before unassociated items"),l(!n.includes(c),"Item cannot come after itself: ".concat(c)),l(!n.includes("?"),"Item cannot come after unassociated items"),Array.isArray(y)||(y=[y]);for(const t of y){const s={seq:this._items.length,sort:r,before:e,after:n,group:c,node:t};this._items.push(s)}if(!d.manual){const t=this._sort();l(t,"item",c!=="?"?"added into group ".concat(c):"","created a dependencies error")}return this.nodes}merge(y){Array.isArray(y)||(y=[y]);for(const e of y)if(e)for(const n of e._items)this._items.push(Object.assign({},n));this._items.sort(_.mergeSort);for(let e=0;e<this._items.length;++e)this._items[e].seq=e;const d=this._sort();return l(d,"merge created a dependencies error"),this.nodes}sort(){const y=this._sort();return l(y,"sort created a dependencies error"),this.nodes}_sort(){const y={},d=Object.create(null),e=Object.create(null);for(const s of this._items){const i=s.seq,o=s.group;e[o]=e[o]||[],e[o].push(i),y[i]=s.before;for(const f of s.after)d[f]=d[f]||[],d[f].push(i)}for(const s in y){const i=[];for(const o in y[s]){const f=y[s][o];e[f]=e[f]||[],i.push(...e[f])}y[s]=i}for(const s in d)if(e[s])for(const i of e[s])y[i].push(...d[s]);const n={};for(const s in y){const i=y[s];for(const o of i)n[o]=n[o]||[],n[o].push(s)}const c={},r=[];for(let s=0;s<this._items.length;++s){let i=s;if(n[s]){i=null;for(let o=0;o<this._items.length;++o){if(c[o]===!0)continue;n[o]||(n[o]=[]);const f=n[o].length;let a=0;for(let m=0;m<f;++m)c[n[o][m]]&&++a;if(a===f){i=o;break}}}i!==null&&(c[i]=!0,r.push(i))}if(r.length!==this._items.length)return!1;const t={};for(const s of this._items)t[s.seq]=s;this._items=[],this.nodes=[];for(const s of r){const i=t[s];this.nodes.push(i.node),this._items.push(i)}return!0}},_.mergeSort=(y,d)=>y.sort===d.sort?0:y.sort<d.sort?-1:1},5380:(O,x,g)=>{const l=g(443),_=g(2178),y={minDomainSegments:2,nonAsciiRx:/[^\x00-\x7f]/,domainControlRx:/[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,tldSegmentRx:/^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,domainSegmentRx:/^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,URL:l.URL||URL};x.analyze=function(d,e={}){if(typeof d!="string")throw new Error("Invalid input: domain must be a string");if(!d)return _.code("DOMAIN_NON_EMPTY_STRING");if(d.length>256)return _.code("DOMAIN_TOO_LONG");if(y.nonAsciiRx.test(d)){if(e.allowUnicode===!1)return _.code("DOMAIN_INVALID_UNICODE_CHARS");d=d.normalize("NFC")}if(y.domainControlRx.test(d))return _.code("DOMAIN_INVALID_CHARS");d=y.punycode(d);const n=e.minDomainSegments||y.minDomainSegments,c=d.split(".");if(c.length<n)return _.code("DOMAIN_SEGMENTS_COUNT");if(e.maxDomainSegments&&c.length>e.maxDomainSegments)return _.code("DOMAIN_SEGMENTS_COUNT_MAX");const r=e.tlds;if(r){const t=c[c.length-1].toLowerCase();if(r.deny&&r.deny.has(t)||r.allow&&!r.allow.has(t))return _.code("DOMAIN_FORBIDDEN_TLDS")}for(let t=0;t<c.length;++t){const s=c[t];if(!s.length)return _.code("DOMAIN_EMPTY_SEGMENT");if(s.length>63)return _.code("DOMAIN_LONG_SEGMENT");if(t<c.length-1){if(!y.domainSegmentRx.test(s))return _.code("DOMAIN_INVALID_CHARS")}else if(!y.tldSegmentRx.test(s))return _.code("DOMAIN_INVALID_TLDS_CHARS")}return null},x.isValid=function(d,e){return!x.analyze(d,e)},y.punycode=function(d){try{return new y.URL("http://".concat(d)).host}catch{return d}}},1745:(O,x,g)=>{const l=g(9848),_=g(5380),y=g(2178),d={nonAsciiRx:/[^\x00-\x7f]/,encoder:new(l.TextEncoder||TextEncoder)};x.analyze=function(e,n){return d.email(e,n)},x.isValid=function(e,n){return!d.email(e,n)},d.email=function(e,n={}){if(typeof e!="string")throw new Error("Invalid input: email must be a string");if(!e)return y.code("EMPTY_STRING");const c=!d.nonAsciiRx.test(e);if(!c){if(n.allowUnicode===!1)return y.code("FORBIDDEN_UNICODE");e=e.normalize("NFC")}const r=e.split("@");if(r.length!==2)return r.length>2?y.code("MULTIPLE_AT_CHAR"):y.code("MISSING_AT_CHAR");const[t,s]=r;if(!t)return y.code("EMPTY_LOCAL");if(!n.ignoreLength){if(e.length>254)return y.code("ADDRESS_TOO_LONG");if(d.encoder.encode(t).length>64)return y.code("LOCAL_TOO_LONG")}return d.local(t,c)||_.analyze(s,n)},d.local=function(e,n){const c=e.split(".");for(const r of c){if(!r.length)return y.code("EMPTY_LOCAL_SEGMENT");if(n){if(!d.atextRx.test(r))return y.code("INVALID_LOCAL_CHARS")}else for(const t of r){if(d.atextRx.test(t))continue;const s=d.binary(t);if(!d.atomRx.test(s))return y.code("INVALID_LOCAL_CHARS")}}},d.binary=function(e){return Array.from(d.encoder.encode(e)).map(n=>String.fromCharCode(n)).join("")},d.atextRx=/^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/,d.atomRx=new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])","(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})","(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"))},2178:(O,x)=>{x.codes={EMPTY_STRING:"Address must be a non-empty string",FORBIDDEN_UNICODE:"Address contains forbidden Unicode characters",MULTIPLE_AT_CHAR:"Address cannot contain more than one @ character",MISSING_AT_CHAR:"Address must contain one @ character",EMPTY_LOCAL:"Address local part cannot be empty",ADDRESS_TOO_LONG:"Address too long",LOCAL_TOO_LONG:"Address local part too long",EMPTY_LOCAL_SEGMENT:"Address local part contains empty dot-separated segment",INVALID_LOCAL_CHARS:"Address local part contains invalid character",DOMAIN_NON_EMPTY_STRING:"Domain must be a non-empty string",DOMAIN_TOO_LONG:"Domain too long",DOMAIN_INVALID_UNICODE_CHARS:"Domain contains forbidden Unicode characters",DOMAIN_INVALID_CHARS:"Domain contains invalid character",DOMAIN_INVALID_TLDS_CHARS:"Domain contains invalid tld character",DOMAIN_SEGMENTS_COUNT:"Domain lacks the minimum required number of segments",DOMAIN_SEGMENTS_COUNT_MAX:"Domain contains too many segments",DOMAIN_FORBIDDEN_TLDS:"Domain uses forbidden TLD",DOMAIN_EMPTY_SEGMENT:"Domain contains empty dot-separated segment",DOMAIN_LONG_SEGMENT:"Domain contains dot-separated segment that is too long"},x.code=function(g){return{code:g,error:x.codes[g]}}},9959:(O,x,g)=>{const l=g(375),_=g(5752);x.regex=function(y={}){l(y.cidr===void 0||typeof y.cidr=="string","options.cidr must be a string");const d=y.cidr?y.cidr.toLowerCase():"optional";l(["required","optional","forbidden"].includes(d),"options.cidr must be one of required, optional, forbidden"),l(y.version===void 0||typeof y.version=="string"||Array.isArray(y.version),"options.version must be a string or an array of string");let e=y.version||["ipv4","ipv6","ipvfuture"];Array.isArray(e)||(e=[e]),l(e.length>=1,"options.version must have at least 1 version specified");for(let t=0;t<e.length;++t)l(typeof e[t]=="string","options.version must only contain strings"),e[t]=e[t].toLowerCase(),l(["ipv4","ipv6","ipvfuture"].includes(e[t]),"options.version contains unknown version "+e[t]+" - must be one of ipv4, ipv6, ipvfuture");e=Array.from(new Set(e));const n=e.map(t=>{if(d==="forbidden")return _.ip[t];const s="\\/".concat(t==="ipv4"?_.ip.v4Cidr:_.ip.v6Cidr);return d==="required"?"".concat(_.ip[t]).concat(s):"".concat(_.ip[t],"(?:").concat(s,")?")}),c="(?:".concat(n.join("|"),")"),r=new RegExp("^".concat(c,"$"));return{cidr:d,versions:e,regex:r,raw:c}}},5752:(O,x,g)=>{const l=g(375),_=g(6064),y={generate:function(){const d={},e="!\\$&'\\(\\)\\*\\+,;=",n="\\w-\\.~%\\dA-Fa-f"+e+":@",c="["+n+"]",r="(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";d.ipv4address="(?:"+r+"\\.){3}"+r;const t="[\\dA-Fa-f]{1,4}",s="(?:"+t+":"+t+"|"+d.ipv4address+")",i="(?:"+t+":){6}"+s,o="::(?:"+t+":){5}"+s,f="(?:"+t+")?::(?:"+t+":){4}"+s,a="(?:(?:"+t+":){0,1}"+t+")?::(?:"+t+":){3}"+s,m="(?:(?:"+t+":){0,2}"+t+")?::(?:"+t+":){2}"+s,v="(?:(?:"+t+":){0,3}"+t+")?::"+t+":"+s,b="(?:(?:"+t+":){0,4}"+t+")?::"+s;d.ipv4Cidr="(?:\\d|[1-2]\\d|3[0-2])",d.ipv6Cidr="(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])",d.ipv6address="(?:"+i+"|"+o+"|"+f+"|"+a+"|"+m+"|"+v+"|"+b+"|(?:(?:[\\dA-Fa-f]{1,4}:){0,5}[\\dA-Fa-f]{1,4})?::[\\dA-Fa-f]{1,4}|(?:(?:[\\dA-Fa-f]{1,4}:){0,6}[\\dA-Fa-f]{1,4})?::)",d.ipvFuture="v[\\dA-Fa-f]+\\.[\\w-\\.~"+e+":]+",d.scheme="[a-zA-Z][a-zA-Z\\d+-\\.]*",d.schemeRegex=new RegExp(d.scheme);const u="[\\w-\\.~%\\dA-Fa-f"+e+":]*",p="(?:\\[(?:"+d.ipv6address+"|"+d.ipvFuture+")\\]|"+d.ipv4address+"|[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=]{1,255})",h="(?:"+u+"@)?"+p+"(?::\\d*)?",$="(?:"+u+"@)?("+p+")(?::\\d*)?",A=c+"+",R="(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*",F="\\/(?:"+A+R+")?",L=A+R,V="[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=@]+"+R;return d.hierPart="(?:(?:\\/\\/"+h+R+")|"+F+"|"+L+"|(?:\\/\\/\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*))",d.hierPartCapture="(?:(?:\\/\\/"+$+R+")|"+F+"|"+L+")",d.relativeRef="(?:(?:\\/\\/"+h+R+")|"+F+"|"+V+"|)",d.relativeRefCapture="(?:(?:\\/\\/"+$+R+")|"+F+"|"+V+"|)",d.query="["+n+"\\/\\?]*(?=#|$)",d.queryWithSquareBrackets="["+n+"\\[\\]\\/\\?]*(?=#|$)",d.fragment="["+n+"\\/\\?]*",d}};y.rfc3986=y.generate(),x.ip={v4Cidr:y.rfc3986.ipv4Cidr,v6Cidr:y.rfc3986.ipv6Cidr,ipv4:y.rfc3986.ipv4address,ipv6:y.rfc3986.ipv6address,ipvfuture:y.rfc3986.ipvFuture},y.createRegex=function(d){const e=y.rfc3986,n="(?:\\?"+(d.allowQuerySquareBrackets?e.queryWithSquareBrackets:e.query)+")?(?:#"+e.fragment+")?",c=d.domain?e.relativeRefCapture:e.relativeRef;if(d.relativeOnly)return y.wrap(c+n);let r="";if(d.scheme){l(d.scheme instanceof RegExp||typeof d.scheme=="string"||Array.isArray(d.scheme),"scheme must be a RegExp, String, or Array");const i=[].concat(d.scheme);l(i.length>=1,"scheme must have at least 1 scheme specified");const o=[];for(let f=0;f<i.length;++f){const a=i[f];l(a instanceof RegExp||typeof a=="string","scheme at position "+f+" must be a RegExp or String"),a instanceof RegExp?o.push(a.source.toString()):(l(e.schemeRegex.test(a),"scheme at position "+f+" must be a valid scheme"),o.push(_(a)))}r=o.join("|")}const t="(?:"+(r?"(?:"+r+")":e.scheme)+":"+(d.domain?e.hierPartCapture:e.hierPart)+")",s=d.allowRelative?"(?:"+t+"|"+c+")":t;return y.wrap(s+n,r)},y.wrap=function(d,e){return{raw:d="(?=.)(?!https?:/$)".concat(d),regex:new RegExp("^".concat(d,"$")),scheme:e}},y.uriRegex=y.createRegex({}),x.regex=function(d={}){return d.scheme||d.allowRelative||d.relativeOnly||d.allowQuerySquareBrackets||d.domain?y.createRegex(d):y.uriRegex}},1447:(O,x)=>{const g={operators:["!","^","*","/","%","+","-","<","<=",">",">=","==","!=","&&","||","??"],operatorCharacters:["!","^","*","/","%","+","-","<","=",">","&","|","?"],operatorsOrder:[["^"],["*","/","%"],["+","-"],["<","<=",">",">="],["==","!="],["&&"],["||","??"]],operatorsPrefix:["!","n"],literals:{'"':'"',"`":"`","'":"'","[":"]"},numberRx:/^(?:[0-9]*\.?[0-9]*){1}$/,tokenRx:/^[\w\$\#\.\@\:\{\}]+$/,symbol:Symbol("formula"),settings:Symbol("settings")};x.Parser=class{constructor(l,_={}){if(!_[g.settings]&&_.constants)for(const y in _.constants){const d=_.constants[y];if(d!==null&&!["boolean","number","string"].includes(typeof d))throw new Error("Formula constant ".concat(y," contains invalid ").concat(typeof d," value type"))}this.settings=_[g.settings]?_:Object.assign({[g.settings]:!0,constants:{},functions:{}},_),this.single=null,this._parts=null,this._parse(l)}_parse(l){let _=[],y="",d=0,e=!1;const n=r=>{if(d)throw new Error("Formula missing closing parenthesis");const t=_.length?_[_.length-1]:null;if(e||y||r){if(t&&t.type==="reference"&&r===")")return t.type="function",t.value=this._subFormula(y,t.value),void(y="");if(r===")"){const s=new x.Parser(y,this.settings);_.push({type:"segment",value:s})}else if(e){if(e==="]")return _.push({type:"reference",value:y}),void(y="");_.push({type:"literal",value:y})}else if(g.operatorCharacters.includes(y))t&&t.type==="operator"&&g.operators.includes(t.value+y)?t.value+=y:_.push({type:"operator",value:y});else if(y.match(g.numberRx))_.push({type:"constant",value:parseFloat(y)});else if(this.settings.constants[y]!==void 0)_.push({type:"constant",value:this.settings.constants[y]});else{if(!y.match(g.tokenRx))throw new Error("Formula contains invalid token: ".concat(y));_.push({type:"reference",value:y})}y=""}};for(const r of l)e?r===e?(n(),e=!1):y+=r:d?r==="("?(y+=r,++d):r===")"?(--d,d?y+=r:n(r)):y+=r:r in g.literals?e=g.literals[r]:r==="("?(n(),++d):g.operatorCharacters.includes(r)?(n(),y=r,n()):r!==" "?y+=r:n();n(),_=_.map((r,t)=>r.type!=="operator"||r.value!=="-"||t&&_[t-1].type!=="operator"?r:{type:"operator",value:"n"});let c=!1;for(const r of _){if(r.type==="operator"){if(g.operatorsPrefix.includes(r.value))continue;if(!c)throw new Error("Formula contains an operator in invalid position");if(!g.operators.includes(r.value))throw new Error("Formula contains an unknown operator ".concat(r.value))}else if(c)throw new Error("Formula missing expected operator");c=!c}if(!c)throw new Error("Formula contains invalid trailing operator");_.length===1&&["reference","literal","constant"].includes(_[0].type)&&(this.single={type:_[0].type==="reference"?"reference":"value",value:_[0].value}),this._parts=_.map(r=>{if(r.type==="operator")return g.operatorsPrefix.includes(r.value)?r:r.value;if(r.type!=="reference")return r.value;if(this.settings.tokenRx&&!this.settings.tokenRx.test(r.value))throw new Error("Formula contains invalid reference ".concat(r.value));return this.settings.reference?this.settings.reference(r.value):g.reference(r.value)})}_subFormula(l,_){const y=this.settings.functions[_];if(typeof y!="function")throw new Error("Formula contains unknown function ".concat(_));let d=[];if(l){let e="",n=0,c=!1;const r=()=>{if(!e)throw new Error("Formula contains function ".concat(_," with invalid arguments ").concat(l));d.push(e),e=""};for(let t=0;t<l.length;++t){const s=l[t];c?(e+=s,s===c&&(c=!1)):s in g.literals&&!n?(e+=s,c=g.literals[s]):s!==","||n?(e+=s,s==="("?++n:s===")"&&--n):r()}r()}return d=d.map(e=>new x.Parser(e,this.settings)),function(e){const n=[];for(const c of d)n.push(c.evaluate(e));return y.call(e,...n)}}evaluate(l){const _=this._parts.slice();for(let y=_.length-2;y>=0;--y){const d=_[y];if(d&&d.type==="operator"){const e=_[y+1];_.splice(y+1,1);const n=g.evaluate(e,l);_[y]=g.single(d.value,n)}}return g.operatorsOrder.forEach(y=>{for(let d=1;d<_.length-1;)if(y.includes(_[d])){const e=_[d],n=g.evaluate(_[d-1],l),c=g.evaluate(_[d+1],l);_.splice(d,2);const r=g.calculate(e,n,c);_[d-1]=r===0?0:r}else d+=2}),g.evaluate(_[0],l)}},x.Parser.prototype[g.symbol]=!0,g.reference=function(l){return function(_){return _&&_[l]!==void 0?_[l]:null}},g.evaluate=function(l,_){return l===null?null:typeof l=="function"?l(_):l[g.symbol]?l.evaluate(_):l},g.single=function(l,_){if(l==="!")return!_;const y=-_;return y===0?0:y},g.calculate=function(l,_,y){if(l==="??")return g.exists(_)?_:y;if(typeof _=="string"||typeof y=="string"){if(l==="+")return(_=g.exists(_)?_:"")+(g.exists(y)?y:"")}else switch(l){case"^":return Math.pow(_,y);case"*":return _*y;case"/":return _/y;case"%":return _%y;case"+":return _+y;case"-":return _-y}switch(l){case"<":return _<y;case"<=":return _<=y;case">":return _>y;case">=":return _>=y;case"==":return _===y;case"!=":return _!==y;case"&&":return _&&y;case"||":return _||y}return null},g.exists=function(l){return l!=null}},9926:()=>{},5688:()=>{},9708:()=>{},1152:()=>{},443:()=>{},9848:()=>{}},D={},function O(x){var g=D[x];if(g!==void 0)return g.exports;var l=D[x]={exports:{}};return j[x](l,l.exports,O),l.exports}(5107);var j,D})})(ut);var pe=ut.exports;const we={"string.empty":"{{#label}} is required","string.min":"{{#label}} must be min 6 chars","string.max":"{{#label}} must be max 30 chars","any.only":"{{#label}} must match"},Kt=pe.object({name:pe.string().required().max(30).label("Name").messages(we),email:pe.string().required().email({tlds:{allow:!1}}).label("Email").messages(we),password:pe.string().required().min(6).label("Password").messages(we),confirmPassword:pe.string().required().valid(pe.ref("password")).label("Confirm Password").messages(we)}),Zt=Gt(Kt),Yt=re(({className:w})=>{const{register:S,handleSubmit:j,formState:D,reset:O}=Lt({mode:"onChange",resolver:Zt}),{errors:x,isValid:g,isSubmitSuccessful:l}=D;return ee(yt,{className:w,justifyContent:"center",children:Oe(bt,{maxWidth:"xs",children:[ee(Vt,{children:"Sign Up"}),ee(qt,{children:"Create, maintain and store your data with Delta."}),Oe(Ut,{onSubmit:j(y=>{console.log("data : ",y),document.documentElement.scrollTop=0,O()}),children:[l&&ee(zt,{children:"Your Request is Submitted successfully"}),ee("br",{}),Tt.map(({name:y,placeholder:d,type:e})=>{var n;return Oe("div",{children:[ee(Bt,Ue({name:y,placeholder:d,type:e},S(y))),x[y]&&ee(lt,{children:(n=x[y])==null?void 0:n.message})]},y)}),ee(Wt,{value:"Submit",disabled:!g})]})]})})})`
  ${Nt}
`,sr=()=>ee(vt,{children:ee(Yt,{})});export{sr as default};
